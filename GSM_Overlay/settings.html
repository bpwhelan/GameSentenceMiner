<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <style>
    * {
      box-sizing: border-box;
      scrollbar-width: thin;
      scrollbar-color: #5a5a5a #2c2c2c;
    }

    /* WebKit browsers (Chrome, Safari, Edge) */
    *::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    *::-webkit-scrollbar-track {
      background: #2c2c2c;
      border-radius: 10px;
    }

    *::-webkit-scrollbar-thumb {
      background: #5a5a5a;
      border-radius: 10px;
      border: 2px solid #2c2c2c;
      transition: background 0.2s ease;
    }

    *::-webkit-scrollbar-thumb:hover {
      background: #6a6a6a;
    }

    *::-webkit-scrollbar-thumb:active {
      background: #7a7a7a;
    }

    *::-webkit-scrollbar-corner {
      background: #2c2c2c;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      color: #ffffff;
      margin: 0;
      padding: 16px;
      min-height: 100vh;
      line-height: 1.4;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
      gap: 16px;
      margin-top: 20px;
    }

    .settings-grid.single-column {
      grid-template-columns: 1fr;
    }

    h3 {
      margin: 0 0 20px 0;
      font-size: 22px;
      font-weight: 600;
      text-align: center;
      background: linear-gradient(135deg, #ffffff 0%, #cccccc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .setting-group {
      margin-bottom: 16px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .setting-group h4 {
      margin: 0 0 10px 0;
      font-size: 13px;
      font-weight: 500;
      color: #cccccc;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 13px;
      font-weight: 500;
      color: #e0e0e0;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      transition: all 0.2s ease;
    }

    label:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.1);
    }

    label:last-child {
      margin-bottom: 0;
    }

    label.sub-option {
      margin-left: 20px;
      background: rgba(255, 255, 255, 0.01);
      border-left: 2px solid rgba(76, 175, 80, 0.3);
    }

    label.sub-option:hover {
      background: rgba(255, 255, 255, 0.03);
      border-left-color: rgba(76, 175, 80, 0.5);
    }

    .label-text {
      flex: 1;
      margin-right: 12px;
    }

    .input-container {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    input[type="text"],
    input[type="number"],
    select {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      padding: 6px 10px;
      color: #ffffff;
      font-size: 13px;
      min-width: 180px;
      transition: all 0.2s ease;
    }

    select {
      cursor: pointer;
    }

    select option {
      background: #2c2c2c;
      color: #ffffff;
      padding: 6px 10px;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      outline: none;
      border-color: #4CAF50;
      background: rgba(255, 255, 255, 0.12);
      box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
    }

    input[type="text"]:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    input[type="checkbox"] {
      appearance: none;
      width: 18px;
      height: 18px;
      background: rgba(255, 255, 255, 0.08);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      cursor: pointer;
      position: relative;
      transition: all 0.2s ease;
    }

    input[type="checkbox"]:checked {
      background: #4CAF50;
      border-color: #4CAF50;
    }

    input[type="checkbox"]:checked::after {
      content: "✓";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 11px;
      font-weight: bold;
    }

    input[type="checkbox"]:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: 6px;
      transition: all 0.2s ease;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.3);
    }

    .status-indicator.connected {
      background-color: #4CAF50;
      box-shadow: 0 0 6px rgba(76, 175, 80, 0.5);
    }

    .status-indicator.disconnected {
      background-color: #f44336;
      box-shadow: 0 0 6px rgba(244, 67, 54, 0.5);
    }

    .guide-button {
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
      display: inline-block;
      margin-left: 6px;
    }

    .guide-button:hover {
      background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
    }

    .hotkey-info {
      font-size: 11px;
      color: #888;
      margin-top: 2px;
      font-style: italic;
    }

    /* Hotkey capture styling */
    input:focus.capturing-hotkey {
      background: rgba(76, 175, 80, 0.2) !important;
      border-color: #4CAF50 !important;
      box-shadow: 0 0 8px rgba(76, 175, 80, 0.3) !important;
    }

    input.capturing-hotkey::placeholder {
      color: #4CAF50 !important;
      font-style: italic;
    }

    @media (max-width: 1024px) {
      .settings-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 640px) {
      body {
        padding: 12px;
      }

      .container {
        padding: 16px;
      }

      label {
        flex-direction: column;
        align-items: flex-start;
      }

      .label-text {
        margin-right: 0;
        margin-bottom: 6px;
      }

      input[type="text"],
      input[type="number"] {
        min-width: 100%;
      }

      .settings-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
  <style src="shared.css"></style>
</head>

<body>
  <div class="container">
    <h3>Overlay Settings</h3>

    <div class="settings-grid">
    <div class="setting-group">
      <h4>Visibility</h4>
      <label>
        <span class="label-text">Show "Ready" Indicator</span>
        <input type="checkbox" id="showReadyIndicator" />
      </label>
      <label>
        <span class="label-text">Show Fading Border Around Detected Text</span>
        <input type="checkbox" id="showTextBackground" />
      </label>
      <label>
        <span class="label-text">Show Recycled Line Indicator</span>
        <input type="checkbox" id="showRecycledIndicator" />
      </label>
      
    </div>

    <div class="setting-group" id="text-offset-group">
      <h4>Text Offset</h4>
      <label>
        <span class="label-text">
          X Offset
          <div class="hotkey-info">Not typically needed on Windows</div>
        </span>
        <input type="number" id="offsetX" value="0" step="0.1" /><span style="margin-left: 5px;">%</span>
      </label>
      <label>
        <span class="label-text">
          Y Offset
          <div class="hotkey-info">Not typically needed on Windows</div>
        </span>
        <input type="number" id="offsetY" value="0" step="0.1" /><span style="margin-left: 5px;">%</span>
      </label>
      <label>
        <span class="label-text">
          Calibrate/Reset Offset
          <div class="hotkey-info">Opens a tool to help you find the correct offset for your setup, or resets current offsets to 0.</div>
        </span>
        <div class="input-container">
          <button type="button" id="openOffsetHelper" class="guide-button">Calibrate</button>
          <button type="button" id="resetOffset" class="guide-button">Reset</button>
        </div>
      </label>
    </div>

    <div class="setting-group">
      <h4>WebSocket Connections (Don't Change)</h4>
      <label>
        <span class="label-text">Plaintext WebSocket URL</span>
        <div class="input-container">
          <input type="text" id="wsUrl1" value="ws://localhost:55002" />
          <span id="wsstatus1" class="status-indicator connected"></span>
        </div>
      </label>
      <label>
        <span class="label-text">GSM WebSocket URL</span>
        <div class="input-container">
          <input type="text" id="wsUrl2" value="ws://localhost:55499" />
          <span id="wsstatus2" class="status-indicator connected"></span>
        </div>
      </label>
    </div>

    <div class="setting-group">
      <h4>Behavior</h4>
      <label>
        <span class="label-text">Hide Main Box on Startup (Recommended)</span>
        <input type="checkbox" id="hideOnStartup" />
      </label>
      <label>
        <span class="label-text">Auto-Minimize After Inactivity (minutes, 0 = disabled)</span>
        <input type="number" id="afkTimer" value="5" min="0" max="60" />
      </label>
      <label>
        <span class="label-text">Enable Furigana</span>
        <input type="checkbox" id="showFurigana" />
      </label>
      <label class="sub-option">
        <span class="label-text">Hide Furigana on Startup (Toggle with hotkey to show)</span>
        <input type="checkbox" id="hideFuriganaOnStartup" />
      </label>
    </div>

    <div class="setting-group">
      <h4>Manual Mode</h4>
      <label>
        <span class="label-text">Only Show Overlay on Hotkey (Enabled)</span>
        <input type="checkbox" id="manualMode" />
      </label>
      <label>
        <span class="label-text">Manual Mode Type</span>
        <select id="manualModeType">
          <option value="hold">Hold (press and hold to show)</option>
          <option value="toggle">Toggle (press once to show, press again to hide)</option>
        </select>
        <div id="manual-mode-hold-warning" class="hotkey-info" style="color: #ff6b6b; font-size: 10px; display: none;">
          Hold mode is unreliable on Linux (global hotkeys don't emit key-up/repeat consistently). Use Toggle.
        </div>
      </label>
      <label>
        <span class="label-text">
          Hotkey
          <div class="hotkey-info">Press to temporarily show overlay in manual mode</div>
          <div class="hotkey-info" style="color: #4CAF50; font-size: 10px;">Click input and press your desired key
            (modifiers optional)</div>
          <div id="ctrl-warning" class="hotkey-info" style="color: #ff6b6b; font-size: 10px; display: none;">⚠️ Warning:
            Ctrl key may interfere with game controls (text skipping)</div>
        </span>
        <div class="input-container">
          <input type="text" id="showHotkey" value="Shift + Space"
            title="Enter a valid hotkey (e.g., Shift + Space)&#10;&#10;⚠️ WARNING: Avoid Ctrl key in games/visual novels&#10;(Ctrl is commonly used for text skipping)&#10;&#10;Note: Some keys may not work (e.g., numpad +, certain special keys)&#10;Use regular keyboard keys for best compatibility" />
          <button type="button" class="guide-button"
            onclick="window.open('https://www.electronjs.org/docs/latest/tutorial/keyboard-shortcuts', '_blank')">
            Guide
          </button>
        </div>
      </label>
    </div>

    <div class="setting-group">
      <h4>Translation (Experimental)</h4>
      <label>
        <span class="label-text">
          Auto-Request Translation
          <div class="hotkey-info" style="color: #ff6b6b;">⚠️ WIP Feature - Not Recommended</div>
          <div class="hotkey-info">Automatically requests translation when OCR text is received</div>
        </span>
        <div class="input-container">
          <input type="checkbox" id="autoRequestTranslation" />
          <button type="button" class="guide-button"
            onclick="window.open('https://docs.gamesentenceminer.com/docs/guides/ai-features', '_blank')">
            AI Guide
          </button>
        </div>
      </label>
      <label>
        <span class="label-text">
          Translation Hotkey
          <div class="hotkey-info">Press to request/toggle translation visibility</div>
          <div class="hotkey-info" style="color: #4CAF50; font-size: 10px;">Click input and press your desired key (modifiers optional)</div>
          <div id="translate-ctrl-warning" class="hotkey-info" style="color: #ff6b6b; font-size: 10px; display: none;">⚠️ Warning: Ctrl key may interfere with game controls (text skipping)</div>
        </span>
        <div class="input-container">
          <input type="text" id="translateHotkey" value="Alt+T"
            title="Enter a valid hotkey (e.g., Alt+T)&#10;&#10;⚠️ WARNING: Avoid Ctrl key in games/visual novels&#10;(Ctrl is commonly used for text skipping)&#10;&#10;Note: Some keys may not work (e.g., numpad +, certain special keys)&#10;Use regular keyboard keys for best compatibility" />
          <button type="button" class="guide-button"
            onclick="window.open('https://www.electronjs.org/docs/latest/tutorial/keyboard-shortcuts', '_blank')">
            Guide
          </button>
        </div>
      </label>
    </div>

    <div class="setting-group">
      <h4>Texthooker</h4>
      <label>
        <span class="label-text">
          Texthooker URL
          <div class="hotkey-info">The URL to load in the texthooker window.</div>
        </span>
        <input type="text" id="texthookerUrl" value="http://localhost:55000/texthooker" />
      </label>
      <label>
        <span class="label-text">
          Texthooker Hotkey
          <div class="hotkey-info">Toggle the texthooker window.</div>
          <div class="hotkey-info" style="color: #4CAF50; font-size: 10px;">Click input and press your desired key (modifiers optional)</div>
          <div id="texthooker-ctrl-warning" class="hotkey-info" style="color: #ff6b6b; font-size: 10px; display: none;">⚠️ Warning: Ctrl key may interfere with game controls (text skipping)</div>
        </span>
        <div class="input-container">
          <input type="text" id="texthookerHotkey" value="Alt+Shift+R"
            title="Enter a valid hotkey (e.g., Alt+Shift+R)&#10;&#10;⚠️ WARNING: Avoid Ctrl key in games/visual novels&#10;(Ctrl is commonly used for text skipping)&#10;&#10;Note: Some keys may not work (e.g., numpad +, certain special keys)&#10;Use regular keyboard keys for best compatibility" />
          <button type="button" class="guide-button"
            onclick="window.open('https://www.electronjs.org/docs/latest/tutorial/keyboard-shortcuts', '_blank')">
            Guide
          </button>
        </div>
      </label>
    </div>

    <div class="setting-group">
      <h4>Hotkeys</h4>
      <label>
        <span class="label-text">
          Toggle Furigana Hotkey
          <div class="hotkey-info">Show/hide furigana on overlay</div>
          <div class="hotkey-info" style="color: #4CAF50; font-size: 10px;">Click input and press your desired key (modifiers optional)</div>
          <div id="furigana-ctrl-warning" class="hotkey-info" style="color: #ff6b6b; font-size: 10px; display: none;">⚠️ Warning: Ctrl key may interfere with game controls (text skipping)</div>
        </span>
        <div class="input-container">
          <input type="text" id="toggleFuriganaHotkey" value="Alt+F"
            title="Enter a valid hotkey (e.g., Alt+F)&#10;&#10;⚠️ WARNING: Avoid Ctrl key in games/visual novels&#10;(Ctrl is commonly used for text skipping)&#10;&#10;Note: Some keys may not work (e.g., numpad +, certain special keys)&#10;Use regular keyboard keys for best compatibility" />
          <button type="button" class="guide-button"
            onclick="window.open('https://www.electronjs.org/docs/latest/tutorial/keyboard-shortcuts', '_blank')">
            Guide
          </button>
        </div>
      </label>
      <label>
        <span class="label-text">
          Toggle Window Hotkey
          <div class="hotkey-info">Show/hide main overlay box</div>
          <div class="hotkey-info" style="color: #4CAF50; font-size: 10px;">Click input and press your desired key (modifiers optional)</div>
          <div id="togglewindow-ctrl-warning" class="hotkey-info" style="color: #ff6b6b; font-size: 10px; display: none;">⚠️ Warning: Ctrl key may interfere with game controls (text skipping)</div>
        </span>
        <div class="input-container">
          <input type="text" id="toggleWindowHotkey" value="Alt+Shift+H"
            title="Enter a valid hotkey (e.g., Alt+Shift+H)&#10;&#10;⚠️ WARNING: Avoid Ctrl key in games/visual novels&#10;(Ctrl is commonly used for text skipping)&#10;&#10;Note: Some keys may not work (e.g., numpad +, certain special keys)&#10;Use regular keyboard keys for best compatibility" />
          <button type="button" class="guide-button"
            onclick="window.open('https://www.electronjs.org/docs/latest/tutorial/keyboard-shortcuts', '_blank')">
            Guide
          </button>
        </div>
      </label>
      <label>
        <span class="label-text">
          Minimize Hotkey
          <div class="hotkey-info">Minimize/restore overlay window</div>
          <div class="hotkey-info" style="color: #4CAF50; font-size: 10px;">Click input and press your desired key (modifiers optional)</div>
          <div id="minimize-ctrl-warning" class="hotkey-info" style="color: #ff6b6b; font-size: 10px; display: none;">⚠️ Warning: Ctrl key may interfere with game controls (text skipping)</div>
        </span>
        <div class="input-container">
          <input type="text" id="minimizeHotkey" value="Alt+Shift+J"
            title="Enter a valid hotkey (e.g., Alt+Shift+J)&#10;&#10;⚠️ WARNING: Avoid Ctrl key in games/visual novels&#10;(Ctrl is commonly used for text skipping)&#10;&#10;Note: Some keys may not work (e.g., numpad +, certain special keys)&#10;Use regular keyboard keys for best compatibility" />
          <button type="button" class="guide-button"
            onclick="window.open('https://www.electronjs.org/docs/latest/tutorial/keyboard-shortcuts', '_blank')">
            Guide
          </button>
        </div>
      </label>
      <label>
        <span class="label-text">
          Yomitan Settings Hotkey
          <div class="hotkey-info">Open Yomitan dictionary settings</div>
          <div class="hotkey-info" style="color: #4CAF50; font-size: 10px;">Click input and press your desired key (modifiers optional)</div>
          <div id="yomitansettings-ctrl-warning" class="hotkey-info" style="color: #ff6b6b; font-size: 10px; display: none;">⚠️ Warning: Ctrl key may interfere with game controls (text skipping)</div>
        </span>
        <div class="input-container">
          <input type="text" id="yomitanSettingsHotkey" value="Alt+Shift+Y"
            title="Enter a valid hotkey (e.g., Alt+Shift+Y)&#10;&#10;⚠️ WARNING: Avoid Ctrl key in games/visual novels&#10;(Ctrl is commonly used for text skipping)&#10;&#10;Note: Some keys may not work (e.g., numpad +, certain special keys)&#10;Use regular keyboard keys for best compatibility" />
          <button type="button" class="guide-button"
            onclick="window.open('https://www.electronjs.org/docs/latest/tutorial/keyboard-shortcuts', '_blank')">
            Guide
          </button>
        </div>
      </label>
      <label>
        <span class="label-text">
          Overlay Settings Hotkey
          <div class="hotkey-info">Open overlay settings (this window)</div>
          <div class="hotkey-info" style="color: #4CAF50; font-size: 10px;">Click input and press your desired key (modifiers optional)</div>
          <div id="overlaysettings-ctrl-warning" class="hotkey-info" style="color: #ff6b6b; font-size: 10px; display: none;">⚠️ Warning: Ctrl key may interfere with game controls (text skipping)</div>
        </span>
        <div class="input-container">
          <input type="text" id="overlaySettingsHotkey" value="Alt+Shift+S"
            title="Enter a valid hotkey (e.g., Alt+Shift+S)&#10;&#10;⚠️ WARNING: Avoid Ctrl key in games/visual novels&#10;(Ctrl is commonly used for text skipping)&#10;&#10;Note: Some keys may not work (e.g., numpad +, certain special keys)&#10;Use regular keyboard keys for best compatibility" />
          <button type="button" class="guide-button"
            onclick="window.open('https://www.electronjs.org/docs/latest/tutorial/keyboard-shortcuts', '_blank')">
            Guide
          </button>
        </div>
      </label>
    </div>
    </div>

    <div class="settings-grid single-column">
    <div class="setting-group">
      <h4>Developer</h4>
      <label>
        <span class="label-text">
          Mimic Platform
          <div class="hotkey-info">Reloads settings window to apply UI changes for the selected OS.</div>
        </span>
        <select id="platform-override">
          <option value="null">Default</option>
          <option value="win32">Windows</option>
          <option value="linux">Linux</option>
          <option value="darwin">macOS</option>
        </select>
      </label>
    </div>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require("electron");

    async function applyPlatformSpecifics() {
      const platform = await ipcRenderer.invoke('get-effective-platform');

      // Settings that are not supported on Linux
      const disabledOnLinuxSettings = [];

      // Immediately disable listed settings when running on Linux so UI is non-interactive
      if (platform === 'linux') {
        disabledOnLinuxSettings.forEach((settingId) => {
          const el = document.getElementById(settingId);
          if (el) {
            el.disabled = true;
            el.title = 'This setting is disabled on Linux.';
          }
        });

        const manualModeTypeSelect = document.getElementById('manualModeType');
        const manualModeHoldOption = manualModeTypeSelect?.querySelector('option[value="hold"]');
        const manualModeHoldWarning = document.getElementById('manual-mode-hold-warning');
        if (manualModeHoldOption) {
          manualModeHoldOption.disabled = true;
        }
        if (manualModeHoldWarning) {
          manualModeHoldWarning.style.display = 'block';
        }
        if (manualModeTypeSelect && manualModeTypeSelect.value === 'hold') {
          manualModeTypeSelect.value = 'toggle';
          await handleSettingChange('manualModeType', 'toggle', manualModeTypeSelect);
        }
      }

      // Hide Text Offset group on Windows
      if (platform === 'win32') {
        const textOffsetGroup = document.getElementById('text-offset-group');
        if (textOffsetGroup) {
          textOffsetGroup.style.display = 'none';
        }
      }

      // Hide Magpie compatibility settings on non-Windows
      if (platform !== 'win32') {
        const magpieLabel = document.getElementById('magpie-compatibility-label');
        if (magpieLabel) {
          magpieLabel.style.display = 'none';
        }

        // Enforce manual mode on non-windows
        const manualModeCheckbox = document.getElementById('manualMode');
        if (manualModeCheckbox) {
          manualModeCheckbox.checked = true;
          manualModeCheckbox.disabled = true;
          const manualModeLabel = manualModeCheckbox.closest('label');
          if (manualModeLabel) {
            manualModeLabel.title = 'Manual mode is required on Linux and macOS.';
          }
        }

      }

      if (platform !== 'linux') {
        const manualModeTypeSelect = document.getElementById('manualModeType');
        const manualModeHoldOption = manualModeTypeSelect?.querySelector('option[value="hold"]');
        const manualModeHoldWarning = document.getElementById('manual-mode-hold-warning');
        if (manualModeHoldOption) {
          manualModeHoldOption.disabled = false;
        }
        if (manualModeHoldWarning) {
          manualModeHoldWarning.style.display = 'none';
        }
      }
    }

    applyPlatformSpecifics();

    // Unified settings change handler
    // element is optional - if provided we'll check element.disabled there
    async function handleSettingChange(settingKey, value, element) {
      const platform = await ipcRenderer.invoke('get-effective-platform');
      // If the control element is disabled, ignore the change
      try {
        if (element && element.disabled) return;
      } catch (e) {
        // ignore
      }

      // Linux-specific setting restrictions can be added here if needed
      
      console.log(`Setting changed: ${settingKey} = ${value}`);
      ipcRenderer.send("setting-changed", { key: settingKey, value: value });
    }

    // Attach event listeners to all setting controls
    // document.getElementById("fontSize").addEventListener("input", (event) => {
    //   handleSettingChange("fontSize", parseInt(event.target.value));
    // });

    document.getElementById("offsetX").addEventListener("input", (event) => {
      handleSettingChange("offsetX", parseInt(event.target.value));
    });

    document.getElementById("offsetY").addEventListener("input", (event) => {
      handleSettingChange("offsetY", parseInt(event.target.value));
    });

    document.getElementById("openOffsetHelper").addEventListener("click", () => {
      ipcRenderer.send("open-offset-helper");
    });

    document.getElementById("resetOffset").addEventListener("click", () => {
      document.getElementById("offsetX").value = 0;
      document.getElementById("offsetY").value = 0;
      handleSettingChange("offsetX", 0);
      handleSettingChange("offsetY", 0);
    });

    document.getElementById("wsUrl1").addEventListener("blur", (event) => {
      handleSettingChange("weburl1", event.target.value);
    });

    document.getElementById("wsUrl2").addEventListener("blur", (event) => {
      handleSettingChange("weburl2", event.target.value);
    });

    document.getElementById("hideOnStartup").addEventListener("change", (event) => {
      handleSettingChange("hideOnStartup", event.target.checked);
    });

    document.getElementById("manualMode").addEventListener("change", (event) => {
      handleSettingChange("manualMode", event.target.checked);
    });

    document.getElementById("manualModeType").addEventListener("change", (event) => {
      handleSettingChange("manualModeType", event.target.value);
    });

    document.getElementById("showTextBackground").addEventListener("change", (event) => {
      handleSettingChange("showTextBackground", event.target.checked);
    });

    document.getElementById("showReadyIndicator").addEventListener("change", (event) => {
      handleSettingChange("showReadyIndicator", event.target.checked);
    });

    document.getElementById("showFurigana").addEventListener("change", (event) => {
      handleSettingChange("showFurigana", event.target.checked);
    });

    document.getElementById("hideFuriganaOnStartup").addEventListener("change", (event) => {
      handleSettingChange("hideFuriganaOnStartup", event.target.checked);
    });

    document.getElementById("showRecycledIndicator").addEventListener("change", (event) => {
      handleSettingChange("showRecycledIndicator", event.target.checked);
    });

    document.getElementById("autoRequestTranslation").addEventListener("change", (event) => {
      handleSettingChange("autoRequestTranslation", event.target.checked);
    });

    document.getElementById("texthookerUrl").addEventListener("blur", (event) => {
      handleSettingChange("texthookerUrl", event.target.value);
    });

    document.getElementById("afkTimer").addEventListener("input", (event) => {
      let value = parseInt(event.target.value);
      if (isNaN(value) || value < 0) value = 0;
      if (value > 60) value = 60; // Max 60 minutes
      event.target.value = value; // Clamp value in input
      handleSettingChange("afkTimer", value);
    });

    document.getElementById("afkTimer").addEventListener("blur", (event) => {
      let value = parseInt(event.target.value);
      if (isNaN(value) || value < 0) value = 0;
      if (value > 60) value = 60; // Max 60 minutes
      event.target.value = value; // Clamp value in input
      handleSettingChange("afkTimer", value);
    });

    document.getElementById('platform-override').addEventListener('change', (event) => {
      const platform = event.target.value === 'null' ? null : event.target.value;
      ipcRenderer.send('set-platform-override', platform);
    });


    // Smart hotkey capture for manual mode hotkey and furigana toggle hotkey
    let isCapturingHotkey = false;

    // Initialize hotkey input with smart capture
    initializeHotkeyInput("showHotkey", {
      warningElementId: "ctrl-warning",
      showCtrlWarning: true,
      placeholder: "Press keys...",
      settingKey: "showHotkey"
    });
    initializeHotkeyInput("toggleFuriganaHotkey", {
      warningElementId: "furigana-ctrl-warning",
      showCtrlWarning: true,
      placeholder: "Press keys...",
      settingKey: "toggleFuriganaHotkey"
    });
    initializeHotkeyInput("translateHotkey", {
      warningElementId: "translate-ctrl-warning",
      showCtrlWarning: true,
      placeholder: "Press keys...",
      settingKey: "translateHotkey"
    });
    initializeHotkeyInput("toggleWindowHotkey", {
      warningElementId: "togglewindow-ctrl-warning",
      showCtrlWarning: true,
      placeholder: "Press keys...",
      settingKey: "toggleWindowHotkey"
    });
    initializeHotkeyInput("minimizeHotkey", {
      warningElementId: "minimize-ctrl-warning",
      showCtrlWarning: true,
      placeholder: "Press keys...",
      settingKey: "minimizeHotkey"
    });
    initializeHotkeyInput("yomitanSettingsHotkey", {
      warningElementId: "yomitansettings-ctrl-warning",
      showCtrlWarning: true,
      placeholder: "Press keys...",
      settingKey: "yomitanSettingsHotkey"
    });
    initializeHotkeyInput("overlaySettingsHotkey", {
      warningElementId: "overlaysettings-ctrl-warning",
      showCtrlWarning: true,
      placeholder: "Press keys...",
      settingKey: "overlaySettingsHotkey"
    });
    initializeHotkeyInput("texthookerHotkey", {
      warningElementId: "texthooker-ctrl-warning",
      showCtrlWarning: true,
      placeholder: "Press keys...",
      settingKey: "texthookerHotkey"
    });

    // Reusable hotkey input initialization function
    function initializeHotkeyInput(inputId, options = {}) {
      const {
        warningElementId = null,
        showCtrlWarning = false,
        placeholder = "Press keys...",
        settingKey = inputId,
        onCapture = null,
        onValidate = null
      } = options;

      const input = document.getElementById(inputId);
      if (!input) return;

      let isCapturing = false;
      let previousValue = input.value;

      input.addEventListener("focus", (event) => {
        isCapturing = true;
        previousValue = event.target.value; // Store the current value before editing
        event.target.value = placeholder;
        event.target.classList.add("capturing-hotkey");
      });

      input.addEventListener("blur", (event) => {
        isCapturing = false;
        event.target.classList.remove("capturing-hotkey");

        // If no valid hotkey was captured, restore the previous value
        if (event.target.value === placeholder || event.target.value.trim() === "") {
          event.target.value = previousValue;
          return;
        }

        // Handle Ctrl warning
        if (showCtrlWarning && warningElementId) {
          updateCtrlWarning(event.target.value, warningElementId);
        }

        // Only validate and send if we have a real hotkey, not the placeholder
        if (validateHotkey(event.target.value)) {
          previousValue = event.target.value; // Update previous value on successful change
          if (onValidate) {
            onValidate(event.target.value);
          } else {
            handleSettingChange(settingKey, event.target.value, event.target);
          }
        } else {
          alert("Invalid hotkey format. Please use the format: Modifier + Key (e.g., Shift + Space)");
          event.target.value = previousValue; // Restore previous value on invalid input
        }
      });

      input.addEventListener("keydown", (event) => {
        if (!isCapturing) return;

        event.preventDefault();
        event.stopPropagation();

        const accelerator = captureKeyboardEvent(event);
        if (accelerator) {
          event.target.value = accelerator;
          if (onCapture) {
            onCapture(accelerator);
          }
        }
      });

      input.addEventListener("keyup", (event) => {
        if (isCapturing && event.target.value !== placeholder) {
          // Handle Ctrl warning
          if (showCtrlWarning && warningElementId) {
            updateCtrlWarning(event.target.value, warningElementId);
          }

          // Auto-apply the hotkey after a short delay
          setTimeout(() => {
            if (validateHotkey(event.target.value)) {
              if (onValidate) {
                onValidate(event.target.value);
              } else {
                handleSettingChange(settingKey, event.target.value, event.target);
              }
              event.target.blur(); // Exit capture mode
            }
          }, 500);
        }
      });
    }

    // Capture keyboard event and convert to accelerator format
    function captureKeyboardEvent(event) {
      const keys = [];
      const modifiers = [];

      // Capture modifiers in the correct order for Electron
      if (event.ctrlKey || event.metaKey) modifiers.push(event.metaKey ? 'Cmd' : 'Ctrl');
      if (event.altKey) modifiers.push('Alt');
      if (event.shiftKey) modifiers.push('Shift');

      // Map special keys to Electron accelerator format
      const keyMap = {
        ' ': 'Space',
        'Enter': 'Return',
        'Escape': 'Escape',
        'Backspace': 'Backspace',
        'Delete': 'Delete',
        'Tab': 'Tab',
        'ArrowUp': 'Up',
        'ArrowDown': 'Down',
        'ArrowLeft': 'Left',
        'ArrowRight': 'Right',
        'Home': 'Home',
        'End': 'End',
        'PageUp': 'PageUp',
        'PageDown': 'PageDown',
        'Insert': 'Insert',
        'F1': 'F1', 'F2': 'F2', 'F3': 'F3', 'F4': 'F4',
        'F5': 'F5', 'F6': 'F6', 'F7': 'F7', 'F8': 'F8',
        'F9': 'F9', 'F10': 'F10', 'F11': 'F11', 'F12': 'F12',
        'F13': 'F13', 'F14': 'F14', 'F15': 'F15', 'F16': 'F16',
        'F17': 'F17', 'F18': 'F18', 'F19': 'F19', 'F20': 'F20',
        'F21': 'F21', 'F22': 'F22', 'F23': 'F23', 'F24': 'F24'
      };

      // Get the main key
      let mainKey = '';
      if (keyMap[event.key]) {
        mainKey = keyMap[event.key];
      } else if (event.key.length === 1) {
        // Single character keys (letters, numbers, symbols)
        mainKey = event.key.toUpperCase();
      } else if (event.key.startsWith('Digit')) {
        // Number keys
        mainKey = event.key.replace('Digit', '');
      } else if (event.key.startsWith('Key')) {
        // Letter keys  
        mainKey = event.key.replace('Key', '');
      } else {
        // Use the key as-is for other cases
        mainKey = event.key;
      }

      // Don't allow modifier-only combinations
      if (!mainKey || ['Control', 'Alt', 'Shift', 'Meta', 'Cmd'].includes(mainKey)) {
        return null;
      }

      // Build the accelerator string
      let accelerator;
      if (modifiers.length > 0) {
        accelerator = [...modifiers, mainKey].join('+');
      } else {
        accelerator = mainKey;
      }

      return accelerator;
    }

    // Update Ctrl warning visibility
    function updateCtrlWarning(hotkey, warningElementId) {
      const warningElement = document.getElementById(warningElementId);
      if (!warningElement) return;

      if (hotkey && hotkey.includes('Ctrl')) {
        warningElement.style.display = 'block';
      } else {
        warningElement.style.display = 'none';
      }
    }


    // Set manualModeType when settings are preloaded
    ipcRenderer.on("preload-settings", (event, { userSettings }) => {
      if (userSettings.manualModeType) {
        document.getElementById("manualModeType").value = userSettings.manualModeType;
      }
      applyPlatformSpecifics();
    });

    function validateHotkey(hotkey) {
      if (!hotkey || hotkey.trim() === "" || hotkey === "Press keys..." || hotkey === "Add a modifier key (Ctrl, Alt, Shift)") {
        return false;
      }

      // Valid modifiers for Electron accelerators
      const validModifiers = ['Ctrl', 'Cmd', 'Alt', 'Shift'];
      const validKeys = [
        // Letters
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        // Numbers
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        // Function keys
        'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
        'F13', 'F14', 'F15', 'F16', 'F17', 'F18', 'F19', 'F20', 'F21', 'F22', 'F23', 'F24',
        // Special keys
        'Space', 'Return', 'Escape', 'Backspace', 'Delete', 'Tab',
        'Up', 'Down', 'Left', 'Right', 'Home', 'End', 'PageUp', 'PageDown', 'Insert',
        // Symbols (common ones)
        '+', '-', '=', '[', ']', '\\', ';', "'", ',', '.', '/', '`',
        '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_'
      ];

      const parts = hotkey.split('+').map(part => part.trim());

      // Single key (no modifiers) - just validate the key itself
      if (parts.length === 1) {
        return validKeys.includes(parts[0]);
      }

      // Multiple parts - last part is the main key, others are modifiers
      const mainKey = parts[parts.length - 1];
      const modifiers = parts.slice(0, -1);

      // Check if all modifiers are valid
      for (const modifier of modifiers) {
        if (!validModifiers.includes(modifier)) {
          return false;
        }
      }

      // Check if main key is valid
      if (!validKeys.includes(mainKey)) {
        return false;
      }

      return true;
    }

    // Handle settings preload
    ipcRenderer.on("preload-settings", (event, { userSettings, websocketStates }) => {
      const { 
        fontSize, weburl1, weburl2, hideOnStartup, manualMode, manualModeType, 
        showHotkey, pinned, showTextBackground, afkTimer, showFurigana, hideFuriganaOnStartup,
        offsetX, offsetY, toggleFuriganaHotkey, translateHotkey, autoRequestTranslation,
        toggleWindowHotkey, minimizeHotkey, yomitanSettingsHotkey, overlaySettingsHotkey,
        texthookerHotkey, texthookerUrl
      } = userSettings;
      
      // document.getElementById("fontSize").value = fontSize;
      document.getElementById("offsetX").value = offsetX;
      document.getElementById("offsetY").value = offsetY;
      document.getElementById("wsUrl1").value = weburl1;
      document.getElementById("manualMode").checked = manualMode;
      document.getElementById("manualModeType").value = manualModeType || "hold";
      document.getElementById("showHotkey").value = showHotkey;
      document.getElementById("wsUrl2").value = weburl2;
      updateWebSocketStatus("ws1", websocketStates.ws1);
      updateWebSocketStatus("ws2", websocketStates.ws2);
      document.getElementById("hideOnStartup").checked = hideOnStartup;
      document.getElementById("showTextBackground").checked = showTextBackground;
      document.getElementById("afkTimer").value = afkTimer;
      document.getElementById("showReadyIndicator").checked = userSettings.showReadyIndicator;
      document.getElementById("showFurigana").checked = showFurigana;
      document.getElementById("hideFuriganaOnStartup").checked = hideFuriganaOnStartup === true;
      document.getElementById("showRecycledIndicator").checked = userSettings.showRecycledIndicator !== false;
      
      // Load all hotkeys
      if (toggleFuriganaHotkey) document.getElementById("toggleFuriganaHotkey").value = toggleFuriganaHotkey;
      if (translateHotkey) document.getElementById("translateHotkey").value = translateHotkey;
      if (toggleWindowHotkey) document.getElementById("toggleWindowHotkey").value = toggleWindowHotkey;
      if (minimizeHotkey) document.getElementById("minimizeHotkey").value = minimizeHotkey;
      if (yomitanSettingsHotkey) document.getElementById("yomitanSettingsHotkey").value = yomitanSettingsHotkey;
      if (overlaySettingsHotkey) document.getElementById("overlaySettingsHotkey").value = overlaySettingsHotkey;
      if (texthookerHotkey) document.getElementById("texthookerHotkey").value = texthookerHotkey;
      if (texthookerUrl) document.getElementById("texthookerUrl").value = texthookerUrl;
      
      // Load translation settings
      if (autoRequestTranslation !== undefined) {
        document.getElementById("autoRequestTranslation").checked = autoRequestTranslation;
      }

      // Show/hide Ctrl warning based on loaded hotkeys
      const hotkeyWarnings = [
        { hotkey: showHotkey, warningId: 'ctrl-warning' },
        { hotkey: toggleFuriganaHotkey, warningId: 'furigana-ctrl-warning' },
        { hotkey: translateHotkey, warningId: 'translate-ctrl-warning' },
        { hotkey: toggleWindowHotkey, warningId: 'togglewindow-ctrl-warning' },
        { hotkey: minimizeHotkey, warningId: 'minimize-ctrl-warning' },
        { hotkey: yomitanSettingsHotkey, warningId: 'yomitansettings-ctrl-warning' },
        { hotkey: overlaySettingsHotkey, warningId: 'overlaysettings-ctrl-warning' },
        { hotkey: texthookerHotkey, warningId: 'texthooker-ctrl-warning' }
      ];

      hotkeyWarnings.forEach(({ hotkey, warningId }) => {
        if (hotkey && hotkey.includes('Ctrl')) {
          const warning = document.getElementById(warningId);
          if (warning) warning.style.display = 'block';
        }
      });

      applyPlatformSpecifics();
    });

    // Handle websocket status updates
    function updateWebSocketStatus(type, isConnected) {
      const statusElement = document.getElementById(type === "ws1" ? "wsstatus1" : "wsstatus2");
      statusElement.className = `status-indicator ${isConnected ? "connected" : "disconnected"}`;
    }

    ipcRenderer.on("websocket-closed", (event, type) => {
      updateWebSocketStatus(type, false);
    });

    ipcRenderer.on("websocket-opened", (event, type) => {
      updateWebSocketStatus(type, true);
    });

    ipcRenderer.on("update-offset-values", (event, { offsetX, offsetY }) => {
      document.getElementById("offsetX").value = offsetX;
      document.getElementById("offsetY").value = offsetY;
    });

    // On dom loaded, display:none id=ajb-parse-button
    document.addEventListener("DOMContentLoaded", () => {
      const ajbParseButton = document.getElementById("ajb-parse-button");
      if (ajbParseButton) {
        ajbParseButton.style.display = "none";
      }
    });
  </script>
</body>

</html>
