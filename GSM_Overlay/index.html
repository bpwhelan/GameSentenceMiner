<!DOCTYPE html>
<style>
  /* Hidden character for Yomitan popup hiding */
  #yomitan-hide-char {
    position: absolute;
    left: -9999px;
    top: -9999px;
    width: 1px;
    height: 1px;
    opacity: 0;
    pointer-events: none;
    user-select: none;
  }
  
  html {
    height: 100%;
    margin: 0;
    padding: 0;
    display: flex;
    /* HIDE SCROLLBARS */
    overflow: hidden;
    /* flex-direction: column;
    justify-content: flex-end; */
    /* üëà Push content to bottom */

  }

  /* body {
background: rgba(202, 12, 12, 0.692);
  } */

  body {
    overflow: hidden;
  }


  #text {
    position: relative;
    white-space: pre-wrap;
    font-size: 39px;
    background: rgba(15, 15, 15, 0);
    color: rgba(255, 255, 255, 0);
    min-height: 25px;
    text-align: start;
    resize: none;
    overflow: auto;
  }

  .text {
    background: rgba(15, 15, 15, 0);
    color: rgba(255, 255, 255, 0);
    min-height: 25px;
    text-align: start;
    overflow: auto;
  }

  .text-box {
    position: absolute;
    white-space: nowrap;
    background: rgba(15, 15, 15, 0);
    color: rgba(255, 255, 255, 0);
    text-align: start;
    pointer-events: auto;
    user-select: text;
    z-index: 999;
    line-height: 1;
    display: block;
    align-items: center;
    justify-content: flex-start;
    overflow: visible;
  }

  .text-box.passive-punctuation {
    pointer-events: none;
    user-select: none;
  }

  .furigana-box {
    position: absolute;
    text-align: center;
    color: white;
    /* background: rgba(15, 15, 15, 0.856);*/
    z-index: 1000;
    /* Make sure it's on top */
    pointer-events: none;
    /* Prevent interaction */
    user-select: none;
    /* Prevent text selection */
    text-shadow:
      -2px -2px 0 #222,
      2px -2px 0 #222,
      -2px 2px 0 #222,
      2px 2px 0 #222,
      -2px 0 0 #222,
      2px 0 0 #222,
      0 -2px 0 #222,
      0 2px 0 #222;
  }

  .text-box-container {
    position: absolute;
    white-space: nowrap;
    /* background: rgba(15, 15, 15, 0);
    color: rgba(255, 255, 255, 0); */
    text-align: start;
    pointer-events: auto;
    user-select: text;
    z-index: 1000;
    line-height: 1;
    display: block;
    align-items: center;
    justify-content: flex-start;
    overflow: visible;
  }

  body.force-visible .text-box,
  body:hover .text-box {
    background: rgba(15, 15, 15, 0.856);
    color: white;
    transition: opacity 0.3s ease;
  }

  .text-box:hover {
    background: rgba(15, 15, 15, 0.856);
    color: white;
    transition: opacity 0.3s ease;
  }

  #resize-handle {
    opacity: 0;
    position: absolute;
    width: 16px;
    height: 16px;
    right: 0;
    bottom: 0;
    transform: rotate(180deg);
    background:
      linear-gradient(135deg, transparent 45%, #aaa 45%, #aaa 55%, transparent 55%),
      linear-gradient(135deg, transparent 25%, #aaa 25%, #aaa 35%, transparent 35%),
      linear-gradient(135deg, transparent 5%, #aaa 5%, #aaa 15%, transparent 15%);
    background-repeat: no-repeat;
    background-position: bottom right;
    cursor: se-resize;
    pointer-events: auto;
  }

  #draggable {
    height: 30px;
    background: rgba(0, 0, 0, 0.4);
    display: flex;
    justify-content: flex-end;
    align-items: center;
    padding: 0 8px;
  }

  #main-box {
    position: fixed;
    left: 50%;
    top: 70%;

  }

  .faded {
    background: rgba(0, 0, 0, 0);
  }

  body.force-visible #text,
  body:hover #text {
    background: rgba(15, 15, 15, 0.856);
    color: white;
    transition: opacity 0.3s ease;
  }

  #main-box:hover #boxes:hover #resize-handle .text-box:hover {
    opacity: 1;
  }

  .control-btn {
    background: transparent;
    user-select: none;
    color: white;
    border: none;
    font-size: 16px;
    margin-left: 10px;
    cursor: pointer;
    -webkit-app-region: no-drag;
  }

  .control-btn:hover {
    color: #ff6666;
  }

  #btn-pin {
    color: #ddd2d2a3;
  }

  /* .big-interactive-area:hover {
    background: rgba(15, 15, 15, 0.1);
  } */

  /* Loading Indicator Styles */
  #loading-indicator {
    position: fixed;
    top: 15px;
    left: 15px;
    width: 40px;
    height: 40px;
    z-index: 10000;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  #loading-indicator.show {
    opacity: 1;
  }

  #loading-indicator.fade-out {
    opacity: 0;
    transition: opacity 1.5s ease-out;
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top: 2px solid #00ff88;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  .checkmark {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    color: #00ff88;
    font-weight: bold;
    text-shadow: 0 0 3px rgba(0, 255, 136, 0.5);
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }

  /* Alternative pulsing dot indicator */
  .loading-dot {
    width: 12px;
    height: 12px;
    background: #00ff88;
    border-radius: 50%;
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {

    0%,
    100% {
      opacity: 0.4;
      transform: scale(1);
    }

    50% {
      opacity: 1;
      transform: scale(1.2);
    }
  }

  /* Manual Mode Recommendation Banner */
  #manual-mode-recommendation {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(30, 144, 255, 0.95);
    color: white;
    padding: 15px 25px;
    border-radius: 10px;
    border: 2px solid rgba(65, 165, 255, 0.8);
    box-shadow: 0 4px 20px rgba(30, 144, 255, 0.4);
    z-index: 10002;
    display: none;
    align-items: center;
    gap: 15px;
    font-size: 16px;
    font-weight: 500;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    pointer-events: auto;
    animation: slideDown 0.3s ease-out;
  }

  #manual-mode-recommendation.visible {
    display: flex;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateX(-50%) translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  }

  .recommendation-icon {
    font-size: 24px;
    flex-shrink: 0;
  }

  /* Gamepad Navigation Styles */
  #gamepad-block-highlight {
    animation: gamepad-pulse 1.5s ease-in-out infinite;
  }

  @keyframes gamepad-pulse {
    0%, 100% {
      opacity: 0.8;
    }
    50% {
      opacity: 1;
    }
  }

  #gamepad-cursor-highlight {
    animation: cursor-blink 0.8s ease-in-out infinite;
  }

  @keyframes cursor-blink {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.6;
    }
  }

  #gamepad-mode-indicator {
    animation: indicator-glow 2s ease-in-out infinite;
  }

  @keyframes indicator-glow {
    0%, 100% {
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }
    50% {
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
    }
  }

  /* Gamepad connection status indicator */
  #gamepad-status {
    position: fixed;
    bottom: 15px;
    left: 15px;
    padding: 6px 12px;
    background: rgba(0, 0, 0, 0.8);
    color: #888;
    border-radius: 6px;
    font-size: 12px;
    z-index: 10000;
    display: none;
    pointer-events: none;
    transition: all 0.3s ease;
  }

  #gamepad-status.connected {
    color: #00ff88;
    display: block;
  }

  #gamepad-status.active {
    color: #ffcc00;
    border: 1px solid #ffcc00;
  }

  .recommendation-text {
    flex: 1;
    line-height: 1.4;
  }

  .recommendation-buttons {
    display: flex;
    gap: 10px;
    flex-shrink: 0;
  }

  .recommendation-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    text-shadow: none;
  }

  .recommendation-btn-primary {
    background: white;
    color: #1e90ff;
  }

  .recommendation-btn-primary:hover {
    background: #f0f0f0;
    transform: scale(1.05);
  }

  .recommendation-btn-secondary {
    background: rgba(255, 255, 255, 0.2);
    color: white;
  }

  .recommendation-btn-secondary:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
  }

  /* Action Panel Trigger Area */
  /*
  #action-panel-trigger {
    position: fixed;
    top: 0;
    left: 0;
    width: 80px;
    height: 80px;
    z-index: 9998;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  */

  /* Action Panel Trigger Icon */
  /*
  #action-panel-icon {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: rgba(0, 255, 136, 0.15);
    border: 2px solid rgba(0, 255, 136, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    color: rgba(0, 255, 136, 0.5);
    transition: all 0.3s ease;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.1);
    pointer-events: none;
  }

  #action-panel-trigger:hover #action-panel-icon {
    background: rgba(0, 255, 136, 0.3);
    border-color: rgba(0, 255, 136, 0.6);
    color: rgba(0, 255, 136, 0.9);
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
    transform: scale(1.1);
  }
  */

  /* Action Panel Styles */
  /*
  #action-panel {
    position: fixed;
    top: 15px;
    left: 15px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid rgba(0, 255, 136, 0.5);
    border-radius: 10px;
    padding: 15px;
    z-index: 9999;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease, transform 0.3s ease;
    transform: translateX(-10px);
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
  }

  #action-panel.visible {
    opacity: 1;
    transform: translateX(0);
    pointer-events: auto;
  }
  */

  /* Startup hint animation */
  /*
  #action-panel.startup-hint {
    opacity: 1;
    transform: translateX(0);
    pointer-events: auto;
    animation: pulse-hint 2s ease-in-out infinite;
  }

  @keyframes pulse-hint {
    0%, 100% {
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
    }
    50% {
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
    }
  }

  #action-panel-buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .action-btn {
    background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 200, 100, 0.2));
    border: 1px solid rgba(0, 255, 136, 0.6);
    color: #00ff88;
    padding: 10px 20px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
    user-select: none;
    box-shadow: 0 2px 8px rgba(0, 255, 136, 0.2);
  }

  .action-btn:hover {
    background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 200, 100, 0.4));
    border-color: #00ff88;
    box-shadow: 0 4px 12px rgba(0, 255, 136, 0.4);
    transform: translateY(-2px);
  }

  .action-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 6px rgba(0, 255, 136, 0.3);
  }

  .action-btn-icon {
    margin-right: 8px;
    font-size: 16px;
  }
  */

  /* Startup Message */
  #startup-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    color: #00ff88;
    padding: 30px 50px;
    border-radius: 10px;
    font-size: 24px;
    font-weight: bold;
    text-align: center;
    z-index: 10000;
    pointer-events: none;
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    opacity: 1;
    transition: opacity 3s ease-out;
  }

  #startup-message.fade-out {
    opacity: 0;
  }
</style>

<style src="shared.css"></style>
<html>

<head>
  <meta charset="UTF-8">
  <style>

  </style>
</head>


<body style="margin:0px;">
  <!-- Gamepad Status Indicator -->
  <div id="gamepad-status">üéÆ No controller</div>

  <!-- Manual Mode Recommendation Banner -->
  <div id="manual-mode-recommendation">
    <span class="recommendation-icon">üí°</span>
    <div class="recommendation-text">
      <strong>Fullscreen Game Detected:</strong> If you're using exclusive fullscreen mode, manual mode may provide better overlay stability.
    </div>
    <div class="recommendation-buttons">
      <button class="recommendation-btn recommendation-btn-primary" id="btn-enable-manual">
        Enable Manual Mode
      </button>
      <button class="recommendation-btn recommendation-btn-secondary" id="btn-dismiss-recommendation">
        Got it
      </button>
    </div>
  </div>

  <!-- Startup Message -->
  <div id="startup-message">
    GSM Overlay Loaded & Ready!
  </div>

  <!-- Text Loading Indicator -->
  <div id="loading-indicator">
    <div class="loading-spinner"></div>
  </div>

  <!-- Action Panel Trigger Area -->
  <!--
  <div id="action-panel-trigger" class="interactive">
    <div id="action-panel-icon">‚ö°</div>
  </div>
  -->

  <!-- Action Panel -->
  <!--
  <div id="action-panel">
    <div id="action-panel-buttons">
      <button class="action-btn" id="btn-scan">
        <span class="action-btn-icon">üîç</span>Run Scan
      </button>
      <button class="action-btn" id="btn-translate">
        <span class="action-btn-icon">üåê</span>Translate
      </button>
      <button class="action-btn" id="btn-tts">
        <span class="action-btn-icon">üîä</span>TTS
      </button>
    </div>
  </div>
  -->

  <div id="main-box" style="display: none;">
    <div draggable="false" id="draggable" class="interactive">
      <button class="control-btn" id="btn-pin">‚¨§</button>
      <button class="control-btn" id="btn-translate-toolbar">üåê</button>
      <button class="control-btn" id="btn-settings">‚öô</button>
      <button class="control-btn" id="btn-yomitan"><img src="yomitan-icon.svg"></button>
      <button class="control-btn" id="btn-minimize">‚ûñ</button>
      <button class="control-btn" id="btn-close">‚úñ</button>
    </div>
    <div id="text" class="interactive">Hide this box with Alt+Shift+H</div>
    <div draggable="false" id="resize-handle" class="interactive half-interactive"></div>
  </div>
  <!-- <div id="text-box-container" class="text-box-container interactive"></div> -->
  <!-- <p id="text-box-paragraph" style="width: 100%; height: 100%;"></p> -->
</body>


<script>
  let yomitanShowing = false;
  let autoHide = null;
  let hideOnYomitanClose = false;
  // let currentX = 0;
  // let currentY = 0;
  let magpieReleaseInterval = null;
  let manualModeActivatedOnce = false;
  let shouldShowReadyIndicator = true;
  let currentMagpieInfo = null; // Store magpie info from websocket
  let isMagpieActive = false; // Track if magpie scaling is active
  
  // let actionPanelStartupHintShown = false; // Track if startup hint was shown
  // let actionPanelShowing = false; // Track if action panel is currently showing
  
  // Track multiple Yomitan popups for nested lookups
  let yomitanPopupCount = 0;
  let yomitanPopupIds = new Set(); // Track unique popup IDs to prevent double-counting

  // Manual mode recommendation state
  let dismissedRecommendationGames = []; // Permanently dismissed games
  let currentGameForRecommendation = null;

  // Startup message fade-out
  window.addEventListener('DOMContentLoaded', () => {
    const startupMessage = document.getElementById('startup-message');
    if (startupMessage) {
      // Start fading after page is fully loaded
      setTimeout(() => {
        startupMessage.classList.add('fade-out');
        // Remove from DOM after fade completes
        setTimeout(() => {
          startupMessage.remove();
        }, 3000);
      }, 100);
    }

    const ajbParseButton = document.getElementById("ajb-parse-button");
    if (ajbParseButton) {
      ajbParseButton.style.display = "none";
    }

    // Show action panel on startup as a hint
    /*
    if (!actionPanelStartupHintShown) {
      showActionPanelStartupHint();
    }
    */
  });

  /*
  function showActionPanelStartupHint() {
    const actionPanel = document.getElementById('action-panel');
    if (actionPanel) {
      console.log('Showing action panel startup hint for 15 seconds');
      actionPanel.classList.add('startup-hint');
      actionPanelStartupHintShown = true;
      
      // Hide after 15 seconds
      setTimeout(() => {
        actionPanel.classList.remove('startup-hint');
        console.log('Action panel startup hint hidden');
      }, 5000);
    }
  }
  */

  // Show action panel on hover (no Shift required)
  // const actionPanel = document.getElementById('action-panel');
  // const actionPanelTrigger = document.getElementById('action-panel-trigger');
  const loadingIndicator = document.getElementById('loading-indicator');

  /*
  function showActionPanel() {
    // Don't show if startup hint is still active
    if (!actionPanel.classList.contains('startup-hint')) {
      actionPanel.classList.add('visible');
      console.log('Showing action panel on hover');
    }
  }

  function hideActionPanel() {
    actionPanel.classList.remove('visible');
  }
  */

  // Set up mouse event handlers for action panel trigger immediately
  /*
  actionPanelTrigger.addEventListener('mouseenter', () => {
    console.log('Mouse entered trigger area');
    ipcRenderer.send('set-ignore-mouse-events', false);
    actionPanelShowing = true;
    showActionPanel();
  });

  actionPanelTrigger.addEventListener('mouseleave', () => {
    console.log('Mouse left trigger area');
    actionPanelShowing = false;
    // Don't hide if mouse moved to the panel itself
    setTimeout(() => {
      const panelHovered = actionPanel.matches(':hover');
      if (!panelHovered) {
        hideActionPanel();
        actionPanelShowing = false;
        ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
      }
    }, 100);
  });

  actionPanel.addEventListener('mouseenter', () => {
    ipcRenderer.send('set-ignore-mouse-events', false);
    actionPanelShowing = true;
  });

  actionPanel.addEventListener('mouseleave', () => {
    hideActionPanel();
    ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
    actionPanelShowing = false;
  });
  */

  // Create big interactive area for action panel trigger when magpie is active
  // let actionPanelBigArea = null;

  /*
  function updateActionPanelMagpieArea() {
    // Remove existing big area if it exists
    if (actionPanelBigArea && actionPanelBigArea.parentNode) {
      actionPanelBigArea.remove();
    }

    if (isMagpieActive && currentMagpieInfo) {
      // Create a big interactive area around the action panel trigger
      actionPanelBigArea = document.createElement('div');
      actionPanelBigArea.className = 'interactive half-interactive action-panel-big-area';
      actionPanelBigArea.id = 'action-panel-big-area';
      actionPanelBigArea.style.position = 'absolute';
      actionPanelBigArea.style.pointerEvents = 'auto';
      actionPanelBigArea.style.zIndex = '9997'; // Below trigger but above other content
      
      // Get the trigger's bounds in percentage (same as text boxes)
      // Trigger is at 0,0 with 80x80px size, which is approximately 0-3.125% x and 0-5.56% y on 2560x1440
      const triggerWidthPercent = (80 / window.innerWidth) * 100;
      const triggerHeightPercent = (80 / window.innerHeight) * 100;
      
      // Transform coordinates using the same method as text boxes
      const topLeft = transformCoordinates(0, 0);
      const bottomRight = transformCoordinates(triggerWidthPercent, triggerHeightPercent);
      
      // Add padding around the trigger (same 25px as text boxes)
      const minx = topLeft.x - 25;
      const miny = topLeft.y - 25;
      const maxx = bottomRight.x + 25;
      const maxy = bottomRight.y + 25;
      
      actionPanelBigArea.style.left = `${minx}px`;
      actionPanelBigArea.style.top = `${miny}px`;
      actionPanelBigArea.style.width = `${maxx - minx}px`;
      actionPanelBigArea.style.height = `${maxy - miny}px`;
      
      document.body.appendChild(actionPanelBigArea);

      // Set up event handlers for the big area
      actionPanelBigArea.addEventListener('mouseenter', () => {
        console.log('Mouse entered action panel big area');
        ipcRenderer.send('set-ignore-mouse-events', false);
        showActionPanel();
      });

      actionPanelBigArea.addEventListener('mouseleave', () => {
        console.log('Mouse left action panel big area');
        setTimeout(() => {
          const triggerHovered = actionPanelTrigger.matches(':hover');
          const panelHovered = actionPanel.matches(':hover');
          if (!triggerHovered && !panelHovered) {
            hideActionPanel();
            ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
          }
        }, 100);
      });

      console.log('Created big interactive area for action panel (magpie mode):', { minx, miny, maxx, maxy });
    } else {
      actionPanelBigArea = null;
    }
  }
  */

  // Action button handlers
  /*
  document.getElementById('btn-scan').addEventListener('click', () => {
    console.log('Scan button clicked');
    ipcRenderer.send('action-scan');
  });

  document.getElementById('btn-translate').addEventListener('click', () => {
    console.log('Translate button clicked');
    ipcRenderer.send('action-translate');
  });

  document.getElementById('btn-tts').addEventListener('click', () => {
    console.log('TTS button clicked');
    ipcRenderer.send('action-tts');
  });
  */

  document.getElementById('btn-translate-toolbar').addEventListener('click', () => {
    console.log('Translate button clicked');
    ipcRenderer.send('action-translate');
  });


  // Safety check: detect stale popup state
  // Since Yomitan popups are in shadow roots, we can't query the DOM directly.
  // Instead, we'll detect if the count seems stuck and hasn't changed in a while.
  let lastPopupChangeTime = Date.now();
  let lastPopupCount = 0;
  const STALE_TIMEOUT = 300000; // 300 seconds, this causes issues, so make it super long, idk.
  
  setInterval(() => {
    // Track when count last changed
    if (yomitanPopupCount !== lastPopupCount) {
      lastPopupChangeTime = Date.now();
      lastPopupCount = yomitanPopupCount;
    }
    
    // If we think popups are showing but it's been a while with no changes,
    // and user isn't actively interacting, reset the state
    const timeSinceChange = Date.now() - lastPopupChangeTime;
    if (yomitanPopupCount > 0 && timeSinceChange > STALE_TIMEOUT) {
      console.warn(`Yomitan popup count appears stale (${yomitanPopupCount} popups for ${timeSinceChange}ms). Resetting...`);
      
      // Reset state
      yomitanPopupCount = 0;
      yomitanPopupIds.clear();
      yomitanShowing = false;
      lastPopupCount = 0;
      lastPopupChangeTime = Date.now();
      
      // Trigger cleanup
      console.log('Resetting stale Yomitan state - triggering cleanup');
      ipcRenderer.send('yomitan-event', false);
      // ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
      
      if (hideOnYomitanClose) {
        hideOnYomitanClose = false;
        if (!pinned) {
          document.body.classList.remove('force-visible');
        }
        hideTextBoxes();
      }
    }
  }, 5000); // Check every 5 seconds

  // window.addEventListener('mousemove', (e) => {
  //   console.log("Mouse moved:", e.clientX, e.clientY);
  //   currentX = e.clientX;
  //   currentY = e.clientY;
  // });

  window.addEventListener('yomitan-popup-shown', (event) => {
    console.log('Yomitan popup shown:', event);
    console.log(event.detail); // This will log the value of 'this' passed above
    
    // Extract popup ID if available, otherwise use timestamp as unique identifier
    const popupId = event.detail?.popupId || `popup-${Date.now()}-${Math.random()}`;
    
    // Only increment if this is a new popup
    if (!yomitanPopupIds.has(popupId)) {
      yomitanPopupIds.add(popupId);
      yomitanPopupCount++;
      console.log(`Yomitan popup opened. Active popups: ${yomitanPopupCount}`, Array.from(yomitanPopupIds));
    }
    
    // Update state based on popup count
    if (yomitanPopupCount > 0) {
      yomitanShowing = true;
      ipcRenderer.send('yomitan-event', true);
    }
  });

  // When popup is hidden, tell main process to ignore mouse events again
  window.addEventListener('yomitan-popup-hidden', (event) => {
    console.log('Yomitan popup hidden:', event);
    
    // Extract popup ID if available
    const popupId = event.detail?.popupId || null;
    
    // Decrement count, ensuring we don't go below 0
    if (popupId && yomitanPopupIds.has(popupId)) {
      yomitanPopupIds.delete(popupId);
      yomitanPopupCount--;
    } else if (!popupId && yomitanPopupCount > 0) {
      // Fallback: decrement by 1 if no ID provided
      yomitanPopupCount--;
      // Clear the oldest entry if we have IDs tracked
      if (yomitanPopupIds.size > 0) {
        const firstId = yomitanPopupIds.values().next().value;
        yomitanPopupIds.delete(firstId);
      }
    }
    
    // Ensure count never goes negative
    yomitanPopupCount = Math.max(0, yomitanPopupCount);
    
    console.log(`Yomitan popup closed. Remaining popups: ${yomitanPopupCount}`, Array.from(yomitanPopupIds));
    
    // Only trigger cleanup when ALL popups are closed
    if (yomitanPopupCount === 0) {
      console.log('All Yomitan popups closed, triggering cleanup');
      yomitanShowing = false;
      yomitanPopupIds.clear(); // Clear the set to prevent memory leaks
      
      ipcRenderer.send('yomitan-event', false);
      // ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
      
      if (hideOnYomitanClose) {
        hideOnYomitanClose = false;
        if (!pinned) {
          document.body.classList.remove('force-visible');
        }
        hideTextBoxes();
      }
    }
  });

  const textElement = document.getElementById("text");
  const handle = document.getElementById("resize-handle");

  let isResizing = false;
  let startX, startY, startWidth, startHeight;

  handle.addEventListener("mousedown", (e) => {
    isResizing = true;
    startX = e.clientX;
    startY = e.clientY;
    const rect = textElement.getBoundingClientRect();
    startWidth = rect.width;
    startHeight = rect.height;
    document.addEventListener("mousemove", resize);
    document.addEventListener("mouseup", stopResize, { once: true });
  });

  function resize(e) {
    if (!isResizing) return;
    const newWidth = startWidth + (e.clientX - startX);
    const newHeight = startHeight + (e.clientY - startY);
    textElement.style.width = newWidth + "px";
    textElement.style.height = newHeight + "px";
  }

  function stopResize() {
    isResizing = false;
    document.removeEventListener("mousemove", resize);
  }


</script>

<script>
  const { ipcRenderer } = require("electron");
  // Try to load OverlayUtils if available (since this is an Electron renderer process)
  let OverlayUtils;
  try {
    OverlayUtils = require("./overlay_utils.js");
    window.OverlayUtils = OverlayUtils;
  } catch (e) {
    console.warn("Could not require overlay_utils.js:", e);
  }

  const dragBar = document.getElementById("draggable");
  const textEl = document.getElementById("text");
  const mainBox = document.getElementById("main-box");

  let isDragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let offsetX = 0;
  let offsetY = 0;
  let hideOnStartup = true;
  let hideYomitanAfterMine = false;
  let usePercentage = false;

  // Listen for mining success signal from Yomitan extension
  window.addEventListener('gsm-anki-note-added', (event) => {
    console.log('Received mining success signal');
    if (hideYomitanAfterMine && OverlayUtils) {
      OverlayUtils.hideYomitan();
    }
  });
  // Bridge: listen for postMessage from Yomitan iframe/extension and re-dispatch as CustomEvent
  window.addEventListener('message', (event) => {
    if (event?.data?.type === 'gsm-anki-note-added') {
      console.log('Received mining success via postMessage');
      window.dispatchEvent(new CustomEvent('gsm-anki-note-added'));
    }
  });
  let unHoverTimer = null;
  let manualMode = false;
  let showHotkey = "Shift + Space";
  let manualHotkeyPressed = false;
  let showTextIndicators = true;
  let fadeTextIndicators = false;
  let showFurigana = false;
  let showRecycledIndicator = true;
  let overlayRenderGeneration = 0;
  let width = 2560;
  let height = 1440;
  let workArea = { x: 0, y: 0, width: 2560, height: 1440 };
  let workAreaWidth = 2560;
  let workAreaHeight = 1392;
  let workAreaAdjustment = (workAreaHeight / height - 1) * -1;

  // Centralized heuristics for OCR line grouping and other tunable math.
  // Edit values here instead of searching for inline thresholds.
  const OVERLAY_TUNING = Object.freeze({
    blockDetection: Object.freeze({
      minDimensionPercent: 0.1,
      minMedianHeightPercent: 0.8,
      fallbackMedianHeightPercent: 1.8,
      sameRow: Object.freeze({
        verticalOverlapRatioMin: 0.35,
        centerYMultiplier: 1.0,
        centerYMinPercent: 1.0,
        centerYMaxPercent: 4.0,
        horizontalGapWidthMultiplier: 0.5,
        horizontalGapPaddingPercent: 3,
        horizontalGapMinPercent: 4,
        horizontalGapMaxPercent: 32,
      }),
      crossRow: Object.freeze({
        verticalGapMinPercent: 1.2,
        verticalGapMedianHeightMultiplier: 0.9,
        verticalGapAvgHeightMultiplier: 0.85,
        centerYMinPercent: 1.5,
        centerYMedianHeightMultiplier: 1.1,
        centerYAvgHeightMultiplier: 1.1,
        xOverlapRatioMin: 0.28,
        minCharWidthPercent: 0.15,
        leftEdgeDiffMinPercent: 2,
        leftEdgeDiffCharWidthMultiplier: 3,
        horizontalGapMinPercent: 3.5,
        horizontalGapCharWidthMultiplier: 4.5,
      }),
    }),
  });

  // Loading indicator functions
  let loadingStartTime = null;
  let readyIndicatorFadeTimer = null;
  let readyIndicatorResetTimer = null;

  function showReadyIndicator() {
    const indicator = document.getElementById('loading-indicator');
    if (!indicator) return;

    if (readyIndicatorFadeTimer) {
      clearTimeout(readyIndicatorFadeTimer);
      readyIndicatorFadeTimer = null;
    }
    if (readyIndicatorResetTimer) {
      clearTimeout(readyIndicatorResetTimer);
      readyIndicatorResetTimer = null;
    }

    indicator.classList.remove('show', 'fade-out');
    indicator.style.transition = 'none';
    indicator.style.opacity = '1';
    indicator.innerHTML = '';
    const checkmark = document.createElement('div');
    checkmark.className = 'checkmark';
    checkmark.textContent = "\u2713";
    indicator.appendChild(checkmark);
    indicator.classList.add('show');
    // Force style flush so transition starts reliably even under rapid updates.
    void indicator.offsetHeight;
    indicator.style.transition = 'opacity 1.1s ease-out';
    readyIndicatorFadeTimer = setTimeout(() => {
      indicator.style.opacity = '0';
    }, 550);
    readyIndicatorResetTimer = setTimeout(() => {
      indicator.classList.remove('show', 'fade-out');
      indicator.style.transition = '';
      indicator.style.opacity = '';
      loadingStartTime = null;
      readyIndicatorFadeTimer = null;
      readyIndicatorResetTimer = null;
    }, 1800);
  }

  dragBar.addEventListener("mousedown", (e) => {
    const rect = mainBox.getBoundingClientRect();
    dragOffsetX = e.clientX - rect.left;
    dragOffsetY = e.clientY - rect.top;
    isDragging = true;
    document.addEventListener("mousemove", onDrag);
    document.addEventListener("mouseup", stopDrag, { once: true });
  });

  function onDrag(e) {
    if (!isDragging) return;
    const newX = Math.max(0, Math.min(window.innerWidth - mainBox.offsetWidth, e.clientX - dragOffsetX));
    const newY = Math.max(0, Math.min(window.innerHeight - mainBox.offsetHeight, e.clientY - dragOffsetY));
    mainBox.style.left = `${newX}px`;
    mainBox.style.top = `${newY}px`;
  }

  function stopDrag() {
    isDragging = false;
    document.removeEventListener("mousemove", onDrag);
  }

  let prevContainer = null;
  const overlaySocketUrls = { ws1: null, ws2: null };
  let overlayMessageProcessing = false;
  const pendingOverlayMessages = [];

  function setupWebSocket(weburl, isPrimary) {
    try {
      const type = isPrimary ? "ws1" : "ws2";
      overlaySocketUrls[type] = new URL(weburl).toString();
    } catch (e) {
      console.warn("Websocket setup error:", e);
    }
  }

  async function processOverlayMessageQueue() {
    if (overlayMessageProcessing) {
      return;
    }
    overlayMessageProcessing = true;
    try {
      while (pendingOverlayMessages.length > 0) {
        const rawData = pendingOverlayMessages.shift();
        await handleOverlayWebSocketData(rawData);
      }
    } finally {
      overlayMessageProcessing = false;
      if (pendingOverlayMessages.length > 0) {
        processOverlayMessageQueue().catch((err) => {
          console.error("Overlay websocket queue processing failed:", err);
        });
      }
    }
  }

  async function handleOverlayWebSocketData(rawData) {
        let data = rawData;
        try {
          data = JSON.parse(rawData);
        } catch (_) {
          data = rawData;
        }

        if (data.config) {
          ipcRenderer.send("config-received", data.config);
        }

        // Handle window state events
        if (data.type === "window_state") {
          console.log("Window state event received:", data.data, "for game:", data.game);
          
          // Process magpie_info from websocket
          if (data.magpie_info !== undefined) {
            const oldMagpieActive = isMagpieActive;
            currentMagpieInfo = data.magpie_info;
            isMagpieActive = currentMagpieInfo !== null && currentMagpieInfo !== undefined;
            
            console.log("Magpie info updated from websocket:", currentMagpieInfo);
            console.log("Magpie active state:", isMagpieActive);
            
            // If magpie state changed, update the behavior
            if (oldMagpieActive !== isMagpieActive) {
              console.log("Magpie state changed from", oldMagpieActive, "to", isMagpieActive);
              updateMagpieCompatibility(isMagpieActive);
              // updateActionPanelMagpieArea();
            }
          }
          
          ipcRenderer.send("window-state-changed", {
            state: data.data,
            game: data.game,
            magpieActive: isMagpieActive,
            isFullscreen: data.is_fullscreen || false,
            recommendManualMode: data.recommend_manual_mode || false
          });
          return; // Don't process as text display
        }

        // Ignore translation-related messages (handled via IPC)
        if (data.type === "translation-result" || data.type === "translation-error") {
          console.log("Translation message received via websocket (ignoring):", data.type);
          return; // Don't process as text display
        }

        // Clear existing text boxes
        const mainBoxBounds = mainBox.getBoundingClientRect();

        console.log(data);

        const isSentenceRecycled = data.is_sentence_recycled;

        let renderedTextPayload = false;

        // Check if data has words array (new word-level coordinate format)
        if (data.type == "word_coordinates" && Array.isArray(data.data) && data.data.every(item => item.text && item.bounding_rect)) {
          renderedTextPayload = true;
          // Handle array of {text, bounding_rect}
          ipcRenderer.send("text-received", data);

          clearTextBoxes();
          const renderGeneration = ++overlayRenderGeneration;
          
          // FIRST PASS: Detect blocks by "general area" (y-first with soft x guards)
          const {
            lineBlocks,
            blockBoundaries,
            blockCount: currentBlockId,
          } = detectTextBlocks(data.data);
          
          console.log("Detected text blocks:", Array.from(blockBoundaries.entries()).map(([blockId, boundaries]) => ({
            blockId,
            start: boundaries.start,
            end: boundaries.end,
          })));
          
          // Log the complete text of each block
          blockBoundaries.forEach((_, blockId) => {
            let blockText = '';
            for (let i = 0; i < data.data.length; i++) {
              if (lineBlocks.get(i) === blockId) {
                blockText += data.data[i].text;
              }
            }
            console.log(`Block ${blockId} text:`, blockText);
          });
          
          // SECOND PASS: Process lines with block awareness
          const blockContainers = new Map(); // Map from block ID to container div
          const frameFragment = document.createDocumentFragment();
          const blockIndicatorBounds = new Map();
          
          for (let lineIdx = 0; lineIdx < data.data.length; lineIdx++) {
            const line = data.data[lineIdx];
            console.log("Processing line:", line);
            
            // Check if this is the start or end of a block
            const blockId = lineBlocks.get(lineIdx);
            const boundaries = blockBoundaries.get(blockId) || { start: lineIdx, end: lineIdx };
            const isBlockStart = lineIdx === boundaries.start;
            const isBlockEnd = lineIdx === boundaries.end;
            
            // Create a container paragraph for this block if it's the start
            if (isBlockStart) {
              const blockContainer = document.createElement('p');
              blockContainer.className = 'text-block-container';
              blockContainer.setAttribute('data-block-id', blockId);
              blockContainer.setAttribute('data-line-start', boundaries.start);
              blockContainer.setAttribute('data-line-end', boundaries.end);
              blockContainer.style.position = 'absolute';
              blockContainer.style.pointerEvents = 'none';
              blockContainer.style.left = '0';
              blockContainer.style.top = '0';
              blockContainer.style.width = '100%';
              blockContainer.style.height = '100%';
              blockContainer.style.margin = '0';
              blockContainer.style.padding = '0';
              frameFragment.appendChild(blockContainer);
              blockContainers.set(blockId, blockContainer);
            }
            
            // Add line break after block ends (create a text node with newline for Yomitan)
            if (isBlockEnd && blockId < currentBlockId - 1) {
              const lineBreak = document.createTextNode('\n');
              const breakSpan = document.createElement('span');
              breakSpan.className = 'block-separator';
              breakSpan.style.position = 'absolute';
              breakSpan.style.pointerEvents = 'none';
              breakSpan.appendChild(lineBreak);
              frameFragment.appendChild(breakSpan);
            }
            
            const rect = line.bounding_rect;
            let minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;
            let bigInteractiveArea = document.createElement("div");
            bigInteractiveArea.className = "big-interactive-area interactive half-interactive";
            if (!/[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uac00-\ud7af]/.test(line.text)) {
              // Not Japanese, Chinese, or Korean: add a spacer span after each box
              const spacer = document.createElement('span');
              spacer.textContent = ' ';
              spacer.style.display = 'inline-block';
              spacer.style.width = '0.5em';
              spacer.className = 'spacer';
              frameFragment.appendChild(spacer);
            }
            // --- NEW: Pre-process logic ---
            // Flatten tokens into single characters with interpolated bounding boxes
            const wordList = [];
            
            // Add line break at start of block
            if (isBlockStart && blockId > 0) {
              wordList.push({
                text: '\n',
                bounding_rect: {
                  x1: line.words[0].bounding_rect.x1,
                  y1: line.words[0].bounding_rect.y1,
                  x3: line.words[0].bounding_rect.x1,
                  y3: line.words[0].bounding_rect.y3
                }
              });
            }
            
            for (const w of line.words) {
              const len = w.text.length;
              // If it's already 1 char, just add it
              if (len <= 1) {
                wordList.push(w);
                continue;
              }
              // If it's a string, split it and calculate positions
              const charWidth = (w.bounding_rect.x3 - w.bounding_rect.x1) / len;
              for (let k = 0; k < len; k++) {
                wordList.push({
                  text: w.text[k],
                  bounding_rect: {
                    x1: w.bounding_rect.x1 + (k * charWidth),
                    y1: w.bounding_rect.y1,
                    x3: w.bounding_rect.x1 + ((k + 1) * charWidth),
                    y3: w.bounding_rect.y3
                  }
                });
              }
            }
            
            // Add line break at end of block
            if (isBlockEnd) {
              const lastWord = line.words[line.words.length - 1];
              wordList.push({
                text: '\n',
                bounding_rect: {
                  x1: lastWord.bounding_rect.x3,
                  y1: lastWord.bounding_rect.y1,
                  x3: lastWord.bounding_rect.x3,
                  y3: lastWord.bounding_rect.y3
                }
              });
            }
            // ------------------------------

            const lineWordFragment = document.createDocumentFragment();
            const lineWordBoxes = [];

            // Iterate over 'wordList'
            for (const word of wordList) {
              const rect = word.bounding_rect;
              let x1 = rect.x1 * 100;
              let y1 = rect.y1 * 100;
              let x3 = rect.x3 * 100;
              let y3 = rect.y3 * 100;

              minx = Math.min(minx, x1);
              miny = Math.min(miny, y1);
              maxx = Math.max(maxx, x3);
              maxy = Math.max(maxy, y3);
              const box = createTextBox(word.text, x1, y1, x3, y3, 0, true, true, false);
              box.dataset.lineIndex = lineIdx;
              lineWordFragment.appendChild(box);

              lineWordBoxes.push({
                box,
                text: word.text,
                widthPercent: x3 - x1,
                heightPercent: y3 - y1,
                viewportRect: getViewportRectFromPercentBounds(x1, y1, x3, y3),
              });
            }

            // Append all line text boxes at once to reduce layout churn.
            const blockContainer = blockContainers.get(blockId);
            if (blockContainer) {
              blockContainer.appendChild(lineWordFragment);
            } else {
              frameFragment.appendChild(lineWordFragment);
            }

            let lineFontTotal = 0;
            let lineFontCount = 0;

            for (const lineWordBox of lineWordBoxes) {
              const estimatedFontSize = estimateFontSize(lineWordBox.text, lineWordBox.widthPercent, lineWordBox.heightPercent);
              lineWordBox.estimatedFontSize = estimatedFontSize;
              if (!isMostlyUnselectableChar(lineWordBox.text)) {
                lineFontTotal += estimatedFontSize;
                lineFontCount++;
              }
            }

            const punctuationFontCap = lineFontCount > 0 ? Math.round(lineFontTotal / lineFontCount) : null;

            for (const lineWordBox of lineWordBoxes) {
              if (pinned && isTextInMainBox(lineWordBox.viewportRect, mainBoxBounds)) {
                console.log("Text inside main box, hiding:", lineWordBox.text);
                lineWordBox.box.style.display = 'none';
                continue;
              }
              let fontSize = lineWordBox.estimatedFontSize;
              if (punctuationFontCap !== null && isMostlyUnselectableChar(lineWordBox.text)) {
                fontSize = Math.min(fontSize, punctuationFontCap);
              }
              lineWordBox.box.style.fontSize = `${fontSize}px`;
            }

            // Keep line and interaction boxes in the same percentage space as text boxes.
            // Backend coordinates are already monitor-relative and include Magpie mapping when active.
            let lineMinx = minx - 0.2;
            let lineMiny = miny - 0.2;
            let lineMaxx = maxx + 0.2;
            let lineMaxy = maxy + 0.2;

            const existingBlockBounds = blockIndicatorBounds.get(blockId);
            if (existingBlockBounds) {
              existingBlockBounds.minx = Math.min(existingBlockBounds.minx, lineMinx);
              existingBlockBounds.miny = Math.min(existingBlockBounds.miny, lineMiny);
              existingBlockBounds.maxx = Math.max(existingBlockBounds.maxx, lineMaxx);
              existingBlockBounds.maxy = Math.max(existingBlockBounds.maxy, lineMaxy);
            } else {
              blockIndicatorBounds.set(blockId, {
                minx: lineMinx,
                miny: lineMiny,
                maxx: lineMaxx,
                maxy: lineMaxy,
              });
            }

            // Use isMagpieActive from websocket instead of deprecated magpieCompatibility setting
            if (isMagpieActive) {
              minx -= 5;
              miny -= 20;
              maxx += 5;
              maxy += 5;
              bigInteractiveArea.style.position = "absolute";
              bigInteractiveArea.style.left = `${minx}%`;
              bigInteractiveArea.style.top = `${miny}%`;
              bigInteractiveArea.style.width = `${maxx - minx}%`;
              bigInteractiveArea.style.height = `${maxy - miny}%`;
            }

            frameFragment.appendChild(bigInteractiveArea);
          }

          blockIndicatorBounds.forEach((bounds) => {
            const blockBox = document.createElement("div");
            blockBox.className = "line-box";
            blockBox.style.position = "absolute";
            blockBox.style.pointerEvents = "none";
            blockBox.style.zIndex = "998";
            blockBox.style.left = `${bounds.minx}%`;
            blockBox.style.top = `${bounds.miny}%`;
            blockBox.style.width = `${bounds.maxx - bounds.minx}%`;
            blockBox.style.height = `${bounds.maxy - bounds.miny}%`;
            applyIndicatorBoxStyles(blockBox);
            frameFragment.appendChild(blockBox);
          });

          // Add recycled sentence indicator if applicable
          if (showRecycledIndicator && isSentenceRecycled && data.data && data.data.length > 0) {
            const firstLine = data.data[0];
            const firstWord = firstLine.words && firstLine.words[0];
            
            if (firstWord && firstWord.bounding_rect) {
              const rect = firstWord.bounding_rect;
              const indicator = document.createElement('div');
              indicator.className = 'recycled-indicator';
              indicator.innerHTML = '&#x21BB;'; // Unicode clockwise open circle arrow (recycling symbol)
              indicator.style.position = 'absolute';
              indicator.style.pointerEvents = 'none';
              indicator.style.zIndex = '999';
              indicator.style.color = '#FFA500'; // Orange color
              indicator.style.fontSize = '32px';
              indicator.style.fontWeight = 'bold';
              indicator.style.textShadow = '0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(255, 165, 0, 0.6)';
              indicator.style.opacity = '0.85';
              indicator.style.userSelect = 'none';
              
              // Position to the left of the first character
              const indicatorOffsetX = -2; // Shift slightly to the left
              const indicatorOffsetY = 1; // Align with text baseline
              
              indicator.style.left = `${(rect.x1 * 100) + indicatorOffsetX}%`;
              indicator.style.top = `${(rect.y1 * 100) + indicatorOffsetY}%`;
              
              frameFragment.appendChild(indicator);
            }
          }

          if (frameFragment.childNodes.length > 0) {
            document.body.appendChild(frameFragment);
          }
          
          renderFuriganaForFrame(data.data, renderGeneration).catch((err) => {
            console.warn('[Furigana] Async render failed:', err);
          });

        } else {
          const line = data?.sentence ?? data;
          if (typeof line === 'string') {
            renderedTextPayload = true;
            document.getElementById("text").textContent = line[0] == '\n' ? line.slice(1) : line;
          } else if (typeof line === 'number' || typeof line === 'boolean') {
            renderedTextPayload = true;
            document.getElementById("text").textContent = String(line);
          }
        }

        if (renderedTextPayload && shouldShowReadyIndicator) {
          showReadyIndicator();
        }
        if (manualMode && !manualHotkeyPressed) {
          hideTextBoxes();
        }

        ipcRenderer.send("text-received", data);
        if (!manualModeActivatedOnce) {
          setMouseEventHandlers();
        }
  }

  ipcRenderer.on("overlay-websocket-data", (event, payload) => {
    if (!payload || typeof payload.data !== "string") {
      return;
    }
    pendingOverlayMessages.push(payload.data);
    processOverlayMessageQueue().catch((err) => {
      console.error("Overlay websocket message handling failed:", err);
    });
  });

  function createTextBox(sentence, x1, y1, x2, y2, fontSize, noBackground = false, transparentText = false, verticalText = false) {
    const textBox = document.createElement('span');
    textBox.className = 'text-box';
    const text = sentence[0] == '\n' ? sentence.slice(1) : sentence;
    textBox.textContent = text;
    const isPassivePunctuation = isMostlyUnselectableChar(text);
    if (isPassivePunctuation) {
      textBox.classList.add('passive-punctuation');
      textBox.dataset.selectable = 'false';
      textBox.style.pointerEvents = 'none';
      textBox.style.userSelect = 'none';
    } else {
      textBox.classList.add('interactive');
      textBox.dataset.selectable = 'true';
    }
    textBox.style.left = `${x1 + offsetX}%`;
    textBox.style.top = `${y1 + offsetY}%`;
    textBox.style.width = `${x2 - x1}%`;
    textBox.style.height = `${y2 - y1}%`;
    textBox.style.display = 'block';
    textBox.style.overflow = 'visible';
    textBox.style.whiteSpace = 'nowrap';
    textBox.style.fontSize = '48px';
    textBox.style.lineHeight = 'normal';
    textBox.style.textOverflow = 'ellipsis';
    textBox.style.background = 'rgba(0,0,0,0)';
    textBox.style.border = 'none';
    if (transparentText) {
      textBox.style.color = 'rgba(255,255,255,0)';
    }

    if (verticalText && /[^\u0000-\u007F]+/.test(sentence)) {
      textBox.style.writingMode = 'vertical-rl';
      textBox.style.textAlign = 'center';
      textBox.style.alignItems = 'flex-start';
      textBox.style.justifyContent = 'center';
      textBox.style.whiteSpace = 'normal';
    } else {
      textBox.style.lineHeight = '1';
      textBox.style.display = 'block';
      textBox.style.overflow = 'visible';
      textBox.style.whiteSpace = 'nowrap';
    }
    return textBox;
  }

function transformCoordinates(x, y) {
    if (!currentMagpieInfo) {
      return { x, y };
    }

    // Calculate dimensions of the Magpie window
    const magpieWidth = currentMagpieInfo.magpieWindowRightEdgePosition - currentMagpieInfo.magpieWindowLeftEdgePosition;
    const magpieHeight = currentMagpieInfo.magpieWindowBottomEdgePosition - currentMagpieInfo.magpieWindowTopEdgePosition;

    // Check if Magpie window is essentially Fullscreen (within 5% of monitor size)
    // Uses global 'width' and 'height' variables
    const isFullscreen = (magpieWidth >= width * 0.95) && (magpieHeight >= height * 0.95);

    if (isFullscreen) {
      // --- YOUR LOGIC (For Fullscreen) ---
      // Uses Source Window coordinates
      const sourceWidth = currentMagpieInfo.sourceWindowRightEdgePosition - currentMagpieInfo.sourceWindowLeftEdgePosition;
      const sourceHeight = currentMagpieInfo.sourceWindowBottomEdgePosition - currentMagpieInfo.sourceWindowTopEdgePosition;
      
      let transformedX = currentMagpieInfo.sourceWindowLeftEdgePosition + (x / 100 * sourceWidth);
      let transformedY = currentMagpieInfo.sourceWindowTopEdgePosition + (y / 100 * sourceHeight);
      
      return { x: transformedX, y: transformedY };
    } else {
      // --- MY LOGIC (For Windowed) ---
      // Uses Magpie Window coordinates to scale correctly when windowed
      let transformedX = currentMagpieInfo.magpieWindowLeftEdgePosition + (x / 100 * magpieWidth);
      let transformedY = currentMagpieInfo.magpieWindowTopEdgePosition + (y / 100 * magpieHeight);
      
      return { x: transformedX, y: transformedY };
    }
  }

  function getViewportRectFromPercentBounds(x1, y1, x3, y3) {
    const left = ((x1 + offsetX) / 100) * window.innerWidth;
    const top = ((y1 + offsetY) / 100) * window.innerHeight;
    const right = ((x3 + offsetX) / 100) * window.innerWidth;
    const bottom = ((y3 + offsetY) / 100) * window.innerHeight;
    return {
      left,
      top,
      right,
      bottom,
      width: right - left,
      height: bottom - top,
    };
  }

  function getAxisGap(minA, maxA, minB, maxB) {
    if (maxA < minB) {
      return minB - maxA;
    }
    if (maxB < minA) {
      return minA - maxB;
    }
    return 0;
  }

  function getAxisOverlap(minA, maxA, minB, maxB) {
    return Math.max(0, Math.min(maxA, maxB) - Math.max(minA, minB));
  }

  function getMedianValue(values) {
    if (!Array.isArray(values) || values.length === 0) {
      return 0;
    }
    const sorted = values
      .filter((v) => Number.isFinite(v))
      .sort((a, b) => a - b);
    if (sorted.length === 0) {
      return 0;
    }
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
      return (sorted[mid - 1] + sorted[mid]) / 2;
    }
    return sorted[mid];
  }

  function shouldLinesShareBlock(lineA, lineB, medianHeight) {
    const cfg = OVERLAY_TUNING.blockDetection;
    const sameRowCfg = cfg.sameRow;
    const crossRowCfg = cfg.crossRow;
    const avgHeight = Math.max(cfg.minDimensionPercent, (lineA.height + lineB.height) / 2);
    const minHeight = Math.max(cfg.minDimensionPercent, Math.min(lineA.height, lineB.height));
    const centerYDiff = Math.abs(lineA.centerY - lineB.centerY);
    const verticalOverlap = getAxisOverlap(lineA.y1, lineA.y3, lineB.y1, lineB.y3);
    const verticalOverlapRatio = verticalOverlap / minHeight;
    const horizontalGap = getAxisGap(lineA.x1, lineA.x3, lineB.x1, lineB.x3);

    const sameRowYThreshold = Math.max(
      sameRowCfg.centerYMinPercent,
      Math.min(sameRowCfg.centerYMaxPercent, avgHeight * sameRowCfg.centerYMultiplier)
    );
    const sameRowGapThreshold = Math.max(
      sameRowCfg.horizontalGapMinPercent,
      Math.min(
        sameRowCfg.horizontalGapMaxPercent,
        ((lineA.width + lineB.width) * sameRowCfg.horizontalGapWidthMultiplier) + sameRowCfg.horizontalGapPaddingPercent
      )
    );
    const sameRow =
      (verticalOverlapRatio >= sameRowCfg.verticalOverlapRatioMin || centerYDiff <= sameRowYThreshold) &&
      horizontalGap <= sameRowGapThreshold;

    if (sameRow) {
      return true;
    }

    const verticalGap = getAxisGap(lineA.y1, lineA.y3, lineB.y1, lineB.y3);
    const verticalGapThreshold = Math.max(
      crossRowCfg.verticalGapMinPercent,
      medianHeight * crossRowCfg.verticalGapMedianHeightMultiplier,
      avgHeight * crossRowCfg.verticalGapAvgHeightMultiplier
    );
    if (verticalGap > verticalGapThreshold) {
      return false;
    }

    const centerYThreshold = Math.max(
      crossRowCfg.centerYMinPercent,
      medianHeight * crossRowCfg.centerYMedianHeightMultiplier,
      avgHeight * crossRowCfg.centerYAvgHeightMultiplier
    );
    if (centerYDiff > centerYThreshold) {
      return false;
    }

    const xOverlap = getAxisOverlap(lineA.x1, lineA.x3, lineB.x1, lineB.x3);
    const minWidth = Math.max(cfg.minDimensionPercent, Math.min(lineA.width, lineB.width));
    const xOverlapRatio = xOverlap / minWidth;
    const leftEdgeDiff = Math.abs(lineA.x1 - lineB.x1);
    const avgCharWidth = Math.max(crossRowCfg.minCharWidthPercent, (lineA.charWidth + lineB.charWidth) / 2);

    return (
      xOverlapRatio >= crossRowCfg.xOverlapRatioMin ||
      leftEdgeDiff <= Math.max(crossRowCfg.leftEdgeDiffMinPercent, avgCharWidth * crossRowCfg.leftEdgeDiffCharWidthMultiplier) ||
      horizontalGap <= Math.max(crossRowCfg.horizontalGapMinPercent, avgCharWidth * crossRowCfg.horizontalGapCharWidthMultiplier)
    );
  }

  function detectTextBlocks(lines) {
    const lineBlocks = new Map();
    const blockBoundaries = new Map();

    if (!Array.isArray(lines) || lines.length === 0) {
      return { lineBlocks, blockBoundaries, blockCount: 0 };
    }

    const metrics = lines.map((line, index) => {
      const rect = line && line.bounding_rect ? line.bounding_rect : {};
      const rawX1 = Number(rect.x1) * 100;
      const rawY1 = Number(rect.y1) * 100;
      const rawX3 = Number(rect.x3) * 100;
      const rawY3 = Number(rect.y3) * 100;

      const safeX1 = Number.isFinite(rawX1) ? rawX1 : 0;
      const safeY1 = Number.isFinite(rawY1) ? rawY1 : 0;
      const safeX3 = Number.isFinite(rawX3) ? rawX3 : safeX1;
      const safeY3 = Number.isFinite(rawY3) ? rawY3 : safeY1;

      const x1 = Math.min(safeX1, safeX3);
      const y1 = Math.min(safeY1, safeY3);
      const x3 = Math.max(safeX1, safeX3);
      const y3 = Math.max(safeY1, safeY3);

      const textLength = typeof line?.text === 'string' && line.text.length > 0 ? line.text.length : 1;
      const width = Math.max(OVERLAY_TUNING.blockDetection.minDimensionPercent, x3 - x1);
      const height = Math.max(OVERLAY_TUNING.blockDetection.minDimensionPercent, y3 - y1);

      return {
        index,
        x1,
        y1,
        x3,
        y3,
        width,
        height,
        centerY: (y1 + y3) / 2,
        charWidth: width / textLength,
      };
    });

    const medianHeight = Math.max(
      OVERLAY_TUNING.blockDetection.minMedianHeightPercent,
      getMedianValue(metrics.map((m) => m.height).filter((h) => Number.isFinite(h) && h > 0)) || OVERLAY_TUNING.blockDetection.fallbackMedianHeightPercent
    );

    const parent = metrics.map((_, idx) => idx);
    const find = (idx) => {
      let current = idx;
      while (parent[current] !== current) {
        parent[current] = parent[parent[current]];
        current = parent[current];
      }
      return current;
    };
    const unite = (a, b) => {
      const rootA = find(a);
      const rootB = find(b);
      if (rootA === rootB) {
        return;
      }
      parent[rootB] = rootA;
    };

    for (let i = 0; i < metrics.length; i++) {
      for (let j = i + 1; j < metrics.length; j++) {
        if (shouldLinesShareBlock(metrics[i], metrics[j], medianHeight)) {
          unite(i, j);
        }
      }
    }

    const components = new Map();
    for (let i = 0; i < metrics.length; i++) {
      const root = find(i);
      if (!components.has(root)) {
        components.set(root, []);
      }
      components.get(root).push(i);
    }

    const orderedComponents = Array.from(components.values())
      .map((memberIndexes) => {
        let top = Infinity;
        let left = Infinity;
        let minIndex = Infinity;
        for (const idx of memberIndexes) {
          const metric = metrics[idx];
          top = Math.min(top, metric.y1);
          left = Math.min(left, metric.x1);
          minIndex = Math.min(minIndex, metric.index);
        }
        return { memberIndexes, top, left, minIndex };
      })
      .sort((a, b) => (a.top - b.top) || (a.left - b.left) || (a.minIndex - b.minIndex));

    orderedComponents.forEach((component, blockId) => {
      for (const idx of component.memberIndexes) {
        lineBlocks.set(idx, blockId);
      }
    });

    for (let i = 0; i < lines.length; i++) {
      const blockId = lineBlocks.get(i);
      if (blockId === undefined) {
        continue;
      }
      if (!blockBoundaries.has(blockId)) {
        blockBoundaries.set(blockId, { start: i, end: i });
      } else {
        const boundary = blockBoundaries.get(blockId);
        boundary.start = Math.min(boundary.start, i);
        boundary.end = Math.max(boundary.end, i);
      }
    }

    return {
      lineBlocks,
      blockBoundaries,
      blockCount: orderedComponents.length,
    };
  }

  const SELECTABLE_LONG_DASH_CHARS = new Set(['\u30FC', '\u2015', '\u2014', '\u2501']);
  let unicodePunctuationMatcher = null;
  try {
    unicodePunctuationMatcher = new RegExp('\\p{P}', 'u');
  } catch (e) {
    unicodePunctuationMatcher = null;
  }
  const fallbackPunctuationMatcher = /[!"#$%&'()*+,./:;<=>?@[\\\]^_`{|}~\u3001\u3002\uFF01\uFF1F\u300C\u300D\u300E\u300F\uFF08\uFF09\uFF3B\uFF3D\uFF5B\uFF5D\u3008\u3009\u300A\u300B\u3010\u3011\u30FB\uFF1A\uFF1B\u2026\u2025\u301C\uFF5E\uFF0C\uFF0E]/u;

  function isSelectableLongDashChar(char) {
    if (typeof char !== 'string' || char.length !== 1) {
      return false;
    }
    return SELECTABLE_LONG_DASH_CHARS.has(char);
  }

  function isMostlyUnselectableChar(char) {
    if (typeof char !== 'string' || char.length !== 1) {
      return false;
    }
    if (isSelectableLongDashChar(char)) {
      return false;
    }
    if (/\s/u.test(char)) {
      return true;
    }
    if (unicodePunctuationMatcher) {
      return unicodePunctuationMatcher.test(char);
    }
    return fallbackPunctuationMatcher.test(char);
  }

  function estimateFontSize(word, widthPercent, heightPercent) {
    const pixelHeight = (heightPercent / 100) * window.innerHeight;
    return Math.max(8, Math.min(100, Math.round(pixelHeight)));
  }

  function buildLineCharacterBoxes(line) {
    const characters = [];
    if (!line || !Array.isArray(line.words)) {
      return characters;
    }

    for (const word of line.words) {
      if (!word || typeof word.text !== 'string' || !word.bounding_rect) {
        continue;
      }
      const text = word.text;
      if (!text.length) {
        continue;
      }
      const rect = word.bounding_rect;
      const charWidth = (rect.x3 - rect.x1) / Math.max(1, text.length);

      for (let i = 0; i < text.length; i++) {
        characters.push({
          text: text[i],
          x1: (rect.x1 + (i * charWidth)) * 100,
          y1: rect.y1 * 100,
          x3: (rect.x1 + ((i + 1) * charWidth)) * 100,
          y3: rect.y3 * 100,
        });
      }
    }

    return characters;
  }

  function createFuriganaBoxesForLine(line, segments) {
    const boxes = [];
    const characters = buildLineCharacterBoxes(line);
    if (characters.length === 0) {
      return boxes;
    }

    for (const segment of segments || []) {
      if (!segment || !segment.hasReading || !segment.reading) {
        continue;
      }

      const start = Number(segment.start);
      const end = Number(segment.end);
      if (!Number.isFinite(start) || !Number.isFinite(end) || start < 0 || end <= start) {
        continue;
      }

      const startChar = characters[start];
      const endChar = characters[end - 1];
      if (!startChar || !endChar) {
        continue;
      }

      const furiganaBox = document.createElement('ruby');
      furiganaBox.className = 'furigana-box';

      const rtElement = document.createElement('rt');
      rtElement.textContent = segment.reading;
      furiganaBox.appendChild(rtElement);

      const segmentWidth = Math.max(0.2, endChar.x3 - startChar.x1);
      const charHeightPx = ((startChar.y3 - startChar.y1) / 100) * window.innerHeight;
      const baseFontSize = Math.max(8, Math.min(100, Math.round(charHeightPx)));
      const furiganaFontSize = baseFontSize * 0.5;
      const furiganaHeight = furiganaFontSize * 1.1;
      const furiganaHeightPercent = (furiganaHeight / window.innerHeight) * 100;
      const furiganaTop = startChar.y1 - furiganaHeightPercent;

      furiganaBox.style.position = 'absolute';
      furiganaBox.style.whiteSpace = 'nowrap';
      furiganaBox.style.overflowX = 'visible';
      furiganaBox.style.overflowY = 'hidden';
      furiganaBox.style.textOverflow = 'unset';
      furiganaBox.style.minWidth = `${segmentWidth}%`;
      furiganaBox.style.width = 'auto';
      furiganaBox.style.padding = '0';
      furiganaBox.style.margin = '0';
      furiganaBox.style.lineHeight = '1';
      furiganaBox.style.display = (furiganaVisible && !(manualMode && !manualHotkeyPressed)) ? 'block' : 'none';
      furiganaBox.style.fontSize = `${furiganaFontSize}px`;
      rtElement.style.fontSize = `${furiganaFontSize}px`;
      furiganaBox.style.left = `${startChar.x1 + offsetX}%`;
      furiganaBox.style.top = `${furiganaTop + offsetY}%`;
      furiganaBox.style.textAlign = 'left';

      boxes.push(furiganaBox);
    }

    return boxes;
  }

  async function renderFuriganaForFrame(lines, renderGeneration) {
    const furiganaReady = gamepadHandler && (
      typeof gamepadHandler.canRequestFurigana === 'function'
        ? gamepadHandler.canRequestFurigana()
        : gamepadHandler.isServerConnected()
    );
    if (!showFurigana || !furiganaReady) {
      return;
    }

    const furiganaRequests = lines.map((line, lineIdx) => {
      if (!line || !line.text || !/[^\u0000-\u007F]/.test(line.text)) {
        return Promise.resolve(null);
      }
      return gamepadHandler.requestFurigana(line.text, lineIdx, 1200)
        .then((result) => ({ line, lineIdx, segments: result.segments || [] }))
        .catch((err) => {
          console.warn(`[Furigana] Failed to get furigana for line ${lineIdx}:`, err);
          return null;
        });
    });

    const resolved = await Promise.all(furiganaRequests);
    if (renderGeneration !== overlayRenderGeneration) {
      return;
    }

    const fragment = document.createDocumentFragment();
    let renderedCount = 0;
    for (const item of resolved) {
      if (!item || !item.segments || item.segments.length === 0) {
        continue;
      }
      const boxes = createFuriganaBoxesForLine(item.line, item.segments);
      for (const box of boxes) {
        fragment.appendChild(box);
        renderedCount++;
      }
    }

    if (renderedCount > 0) {
      document.body.appendChild(fragment);
    }
  }

  function isTextInMainBox(rect, mainBoxBounds) {
    // If mainbox is not visible, return false
    if (mainBox.style.display === "none" || mainBox.style.visibility === "hidden") {
      return false;
    }
    return !(rect.right < mainBoxBounds.left ||
      rect.left > mainBoxBounds.right ||
      rect.bottom < mainBoxBounds.top ||
      rect.top > mainBoxBounds.bottom);
  }


  function setMouseEventHandlers() {
    const interactiveElements = document.querySelectorAll('.interactive');
    const halfInteractiveElements = document.querySelectorAll('.half-interactive');
    const textBoxElements = document.querySelectorAll('.text-box');
    const bigInteractiveAreas = document.querySelectorAll('.big-interactive-area');
    let isMouseOverInteractiveElement = false;

    interactiveElements.forEach((element) => {
      element.addEventListener('mouseenter', (event) => {
        isMouseOverInteractiveElement = true;
        ipcRenderer.send('set-ignore-mouse-events', false);
      });
      if (!element.classList.contains("half-interactive")) {
        element.addEventListener('mouseleave', () => {
          isMouseOverInteractiveElement = false;
          ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
        });
      }
    });

    halfInteractiveElements.forEach((element) => {
      if (!element.classList.contains("interactive")) {
        element.addEventListener('mouseenter', () => {
          isMouseOverInteractiveElement = true;
          ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
        });
      }
    });

    bigInteractiveAreas.forEach((area) => {
      area.addEventListener('click', (event) => {
        // If not a textbox, hide the big interactive area for three seconds.
        if (!event.target.classList.contains('text-box')) {
          ipcRenderer.send('hide');
          setTimeout(() => {
            ipcRenderer.send('show');
          }, 3000);
        }
      });
    });
  }

  // Function to clear all existing text boxes
function clearTextBoxes() {
    // Fast way to clear DOM without leaving residue
    const selectors = ['.text-box', '.big-interactive-area', '.spacer', '.line-box', '.furigana-box', '.recycled-indicator', '.text-block-container', '.block-separator'];
    selectors.forEach(sel => {
        const elements = document.querySelectorAll(sel);
        for (let i = 0; i < elements.length; i++) {
            elements[i].remove();
        }
    });
    
    // Don't remove translation-display here if you want it to persist, 
    // but DO remove it if you're getting new text.
    const trans = document.getElementById('translation-display');
    if (trans) trans.remove();
}

  function hideTextBoxes() {
    const selectors = ['.text-box', '.big-interactive-area', '.spacer', '.line-box', '.furigana-box', '.recycled-indicator', '.text-block-container', '.block-separator'];
    selectors.forEach(sel => {
        const elements = document.querySelectorAll(sel);
        for (let i = 0; i < elements.length; i++) {
            elements[i].style.display = 'none';
        }
    });
    
    // Don't remove translation-display here if you want it to persist, 
    // but DO remove it if you're getting new text.
    const trans = document.getElementById('translation-display');
    if (trans) trans.style.display = 'none';
  }

  function showTextBoxes() {
    const selectors = ['.text-box', '.big-interactive-area', '.spacer', '.line-box', '.recycled-indicator', '.text-block-container'];
    selectors.forEach(sel => {
        const elements = document.querySelectorAll(sel);
        for (let i = 0; i < elements.length; i++) {
            elements[i].style.display = 'block';
        }
    });

    const furiganaBoxes = document.querySelectorAll('.furigana-box');
    for (let i = 0; i < furiganaBoxes.length; i++) {
      furiganaBoxes[i].style.display = furiganaVisible ? 'block' : 'none';
    }
    
    // Don't remove translation-display here if you want it to persist, 
    // but DO remove it if you're getting new text.
    const trans = document.getElementById('translation-display');
    if (trans) trans.style.display = 'block';
  }

  let resizeMode = false;
  let pinned = false;
  document.getElementById("btn-pin").addEventListener("click", () => {
    if (!pinned) {
      document.body.classList.add("force-visible");
      pinned = true;
      document.getElementById("btn-pin").style.color = "#ddd2d2";
      ipcRenderer.send("pinned-changed", true);
    } else {
      document.getElementById("btn-pin").style.color = "#ddd2d2a3";
      document.body.classList.remove("force-visible");
      pinned = false;
      ipcRenderer.send("pinned-changed", false);
    }
  });

  document.getElementById("btn-minimize").addEventListener("click", () => {
    ipcRenderer.send("app-minimize");
  });

  document.getElementById("btn-close").addEventListener("click", () => {
    ipcRenderer.send("app-close");
  });

  document.getElementById("btn-settings").addEventListener("click", () => {
    ipcRenderer.send("open-settings");
  });

  document.getElementById("btn-yomitan").addEventListener("click", () => {
    ipcRenderer.send("open-yomitan-settings");
  });

  // Prevent clicks on non-interactive areas - this won't make THIS click pass through,
  // but ensures FUTURE clicks pass through. The window must already be in ignore mode
  // for clicks to pass through automatically.
  document.addEventListener("click", (event) => {
    // Use composedPath to see into Shadow DOMs
    const path = event.composedPath();
    const isYomitanPopup = path.some(el => 
      el instanceof HTMLElement && (el.classList.contains('yomitan-popup') || el.tagName === 'YOMITAN-POPUP-TAG-NAME')
    );
    
    const target = event.target;
    const isInteractive = target.classList.contains('interactive') || target.closest('.interactive');
    const isActionPanel = false; // target.id === 'action-panel' || target.closest('#action-panel');
    const isActionTrigger = false; // target.id === 'action-panel-trigger' || target.closest('#action-panel-trigger');
    
    if (!isYomitanPopup && !isActionPanel && !isActionTrigger) {
      // Set ignore mode immediately so subsequent mouse events pass through
      ipcRenderer.send("set-ignore-mouse-events", true, { forward: true });
    }
  });

  // Use mousedown to catch events earlier in the chain, giving better pass-through behavior
  document.addEventListener("mousedown", (event) => {
    const path = event.composedPath();
    const isYomitanPopup = path.some(el => 
      el instanceof HTMLElement && (el.classList.contains('yomitan-popup') || el.tagName === 'YOMITAN-POPUP-TAG-NAME')
    );
    
    const target = event.target;
    // const isInteractive = target.classList.contains('interactive') || target.closest('.interactive');
    const isActionPanel = false; // target.id === 'action-panel' || target.closest('#action-panel');
    const isActionTrigger = false; // target.id === 'action-panel-trigger' || target.closest('#action-panel-trigger');
    
    // If clicking on non-interactive area, ensure ignore mode is active
    if (!isYomitanPopup && !isActionPanel && !isActionTrigger) {
      ipcRenderer.send("set-ignore-mouse-events", true, { forward: true });
    }
  });

  ipcRenderer.on("load-settings", (event, newsettings) => {
    textEl.style.fontSize = `${newsettings.fontSize}px`;
    setupWebSocket(newsettings.weburl1, true)
    setupWebSocket(newsettings.weburl2, false)
    hideOnStartup = newsettings.hideOnStartup;
    manualMode = newsettings.manualMode;
    showHotkey = newsettings.showHotkey;
    pinned = newsettings.pinned;
    if (Object.prototype.hasOwnProperty.call(newsettings, "showTextIndicators")) {
      showTextIndicators = newsettings.showTextIndicators !== false;
      fadeTextIndicators = newsettings.fadeTextIndicators === true;
    } else {
      showTextIndicators = true;
      fadeTextIndicators = newsettings.showTextBackground === true;
    }
    shouldShowReadyIndicator = newsettings.showReadyIndicator !== false;
    showFurigana = newsettings.showFurigana;
    hideFuriganaOnStartup = newsettings.hideFuriganaOnStartup === true;
    if (newsettings.hideYomitanAfterMine !== undefined) {
      hideYomitanAfterMine = newsettings.hideYomitanAfterMine;
    }
    
    // Load gamepad settings
    if (newsettings.gamepadTokenMode !== undefined) {
      gamepadSettings.tokenMode = newsettings.gamepadTokenMode;
    }
    if (newsettings.gamepadTokenizerBackend !== undefined) {
      gamepadSettings.tokenizerBackend = newsettings.gamepadTokenizerBackend;
    }
    if (newsettings.gamepadYomitanApiUrl !== undefined) {
      gamepadSettings.yomitanApiUrl = newsettings.gamepadYomitanApiUrl;
    }
    if (newsettings.gamepadYomitanScanLength !== undefined) {
      gamepadSettings.yomitanScanLength = newsettings.gamepadYomitanScanLength;
    }
    if (newsettings.gamepadServerPort !== undefined) {
      gamepadSettings.serverUrl = `ws://localhost:${newsettings.gamepadServerPort}`;
    }
    if (newsettings.gamepadActivationMode !== undefined) {
      gamepadSettings.activationMode = newsettings.gamepadActivationMode;
    }
    if (newsettings.gamepadModifierButton !== undefined) {
      gamepadSettings.modifierButton = newsettings.gamepadModifierButton;
    }
    if (newsettings.gamepadToggleButton !== undefined) {
      gamepadSettings.toggleButton = newsettings.gamepadToggleButton;
    }
    if (newsettings.gamepadConfirmButton !== undefined) {
      gamepadSettings.confirmButton = newsettings.gamepadConfirmButton;
    }
    if (newsettings.gamepadCancelButton !== undefined) {
      gamepadSettings.cancelButton = newsettings.gamepadCancelButton;
    }
    if (newsettings.gamepadShowIndicator !== undefined) {
      gamepadSettings.showIndicator = newsettings.gamepadShowIndicator;
    }
    if (newsettings.gamepadRepeatDelay !== undefined) {
      gamepadSettings.repeatDelay = newsettings.gamepadRepeatDelay;
    }
    if (newsettings.gamepadRepeatRate !== undefined) {
      gamepadSettings.repeatRate = newsettings.gamepadRepeatRate;
    }
    if (newsettings.gamepadControllerEnabled !== undefined) {
      gamepadSettings.controllerEnabled = newsettings.gamepadControllerEnabled;
    }
    if (newsettings.gamepadKeyboardEnabled !== undefined) {
      gamepadSettings.keyboardEnabled = newsettings.gamepadKeyboardEnabled;
    }
    
    // Apply hide furigana on startup if enabled
    if (hideFuriganaOnStartup && showFurigana) {
      furiganaVisible = false;
      // Hide any existing furigana boxes
      const furiganaBoxes = document.querySelectorAll('.furigana-box');
      furiganaBoxes.forEach(box => {
        box.style.display = 'none';
      });
    }
    
    showRecycledIndicator = newsettings.showRecycledIndicator !== false;
    offsetX = newsettings.offsetX || 0;
    offsetY = newsettings.offsetY || 0;
    dismissedRecommendationGames = newsettings.dismissedFullscreenRecommendations || [];
    console.log("Loaded dismissed games:", dismissedRecommendationGames);

    if (pinned) {
      document.body.classList.add("force-visible");
      document.getElementById("btn-pin").style.color = "#ddd2d2";
    } else {
      document.getElementById("btn-pin").style.color = "#ddd2d2a3";
      document.body.classList.remove("force-visible");
    }

    if (hideOnStartup) {
      mainBox.style.display = "none";
    } else {
      mainBox.style.display = "";
    }

    if (magpieReleaseInterval) {
      clearInterval(magpieReleaseInterval);
    }

    // Initialize magpie interval based on current websocket state (isMagpieActive)
    // This will be updated dynamically when window_state messages arrive
    if (isMagpieActive) {
      magpieReleaseInterval = setInterval(() => {
        // && !actionPanelShowing
        if (!yomitanShowing && !manualHotkeyPressed) {
          ipcRenderer.send("set-ignore-mouse-events", true, { forward: true });
        }
      }, 1000);
    }
    
    // Initialize gamepad handler now that settings are loaded
    initGamepad();
  })

  ipcRenderer.on('display-info', (event, newDisplay) => {
    display = newDisplay;
    width = display.size.width;
    height = display.size.height;
    workArea = display.workArea;
    workAreaWidth = workArea.width;
    workAreaHeight = workArea.height;
    workAreaAdjustment = (workAreaHeight / height - 1) * -1;
    console.log("Display info updated:", display);
    console.log(`Work area adjustment factor: ${workAreaAdjustment}`);
  });

  // Unified settings update handler
  ipcRenderer.on("settings-updated", (event, updatedSettings) => {
    console.log("Settings updated:", updatedSettings);

    Object.keys(updatedSettings).forEach(key => {
      const value = updatedSettings[key];

      switch (key) {
        case "fontSize":
          textEl.style.fontSize = `${value}px`;
          break;
        case "weburl1":
          setupWebSocket(value, true);
          break;
        case "weburl2":
          setupWebSocket(value, false);
          break;
        case "hideOnStartup":
          hideOnStartup = value;
          break;
        case "manualMode":
          updateManualMode(value);
          break;
        case "showHotkey":
          showHotkey = value;
          break;
        case "pinned":
          updatePinnedState(value);
          break;
        case "showTextIndicators":
          updateTextIndicators(value, fadeTextIndicators);
          break;
        case "fadeTextIndicators":
          updateTextIndicators(showTextIndicators, value);
          break;
        case "showTextBackground":
          // Legacy compatibility path.
          updateTextIndicators(value, value);
          break;
        case "showReadyIndicator":
          shouldShowReadyIndicator = value !== false;
          break;
        case "showFurigana":
          showFurigana = value;
          break;
        case "hideFuriganaOnStartup":
          hideFuriganaOnStartup = value;
          break;
        case "hideYomitanAfterMine":
          hideYomitanAfterMine = value;
          break;
        case "showRecycledIndicator":
          showRecycledIndicator = value;
          break;
        case "offsetX":
          offsetX = value;
          break;
        case "offsetY":
          offsetY = value;
          break;
      }
    });
  });

  function updateMagpieCompatibility(newValue) {
    // newValue now represents whether magpie is currently active (from websocket)
    // We use the global isMagpieActive state rather than the old magpieCompatibility setting
    console.log("Magpie compatibility behavior update - Active:", isMagpieActive);

    if (magpieReleaseInterval) {
      clearInterval(magpieReleaseInterval);
      magpieReleaseInterval = null;
    }

    if (isMagpieActive) {
      magpieReleaseInterval = setInterval(() => {
        // && !actionPanelShowing
        if (!yomitanShowing && !manualHotkeyPressed) {
          ipcRenderer.send("set-ignore-mouse-events", true, { forward: true });
        }
      }, 1000);
    }

    // Update any UI elements or settings related to magpieCompatibility
    const bigInteractiveAreas = document.querySelectorAll('.big-interactive-area');
    bigInteractiveAreas.forEach(area => {
      const left = parseFloat(area.style.left) || 0;
      const top = parseFloat(area.style.top) || 0;
      const width = parseFloat(area.style.width) || 0;
      const height = parseFloat(area.style.height) || 0;

      if (usePercentage) {
        if (isMagpieActive) {
          area.style.left = (left - 5) + '%';
          area.style.top = (top - 5) + '%';
          area.style.width = (width + 10) + '%';
          area.style.height = (height + 10) + '%';
        } else {
          area.style.left = left + '%';
          area.style.top = top + '%';
          area.style.width = width + '%';
          area.style.height = height + '%';
        }
      }
      else if (isMagpieActive) {
        area.style.left = (left - 100) + 'px';
        area.style.top = (top - 100) + 'px';
        area.style.width = (width + 200) + 'px';
        area.style.height = (height + 200) + 'px';
      } else {
        area.style.left = (left + 100 - 10) + 'px';
        area.style.top = (top + 100 - 10) + 'px';
        area.style.width = (width - 200 + 20) + 'px';
        area.style.height = (height - 200 + 20) + 'px';
      }
    });
  }

  function updateManualMode(newValue) {
    manualMode = newValue;
    if (manualMode) {
      manualModeActivatedOnce = false;
      manualHotkeyPressed = false;
      hideOnYomitanClose = false; // Clear this flag to prevent weird state
      if (!pinned) {
        document.body.classList.remove('force-visible');
      }
      hideTextBoxes();
      ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
    } else {
      // Switching to non-manual mode (automatic mode)
      // Clear any manual mode flags to prevent lockout
      manualHotkeyPressed = false;
      hideOnYomitanClose = false;
      document.body.classList.add('force-visible');
      showTextBoxes();
      ipcRenderer.send('set-ignore-mouse-events', false);
    }
  }

  function updatePinnedState(newValue) {
    pinned = newValue;
    if (pinned) {
      document.body.classList.add("force-visible");
      document.getElementById("btn-pin").style.color = "#ddd2d2";
    } else {
      document.getElementById("btn-pin").style.color = "#ddd2d2a3";
      document.body.classList.remove("force-visible");
    }
  }

  function updateTextBackground(newValue) {
    updateTextIndicators(newValue, fadeTextIndicators);
  }

  function applyIndicatorBoxStyles(lineBox) {
    if (showTextIndicators) {
      lineBox.style.border = '1px solid rgba(255, 0, 0, 0.6)';
      lineBox.style.background = 'rgba(0, 0, 0, 0)';
      if (fadeTextIndicators) {
        lineBox.style.transition = 'border-color 1.5s ease-out, background-color 1.5s ease-out';
        setTimeout(() => {
          lineBox.style.borderColor = 'rgba(255, 0, 0, 0)';
          lineBox.style.background = 'rgba(0, 0, 0, 0)';
        }, 1000);
      } else {
        lineBox.style.transition = 'none';
      }
    } else {
      lineBox.style.transition = 'none';
      lineBox.style.background = 'rgba(0, 0, 0, 0)';
      lineBox.style.border = 'none';
    }
  }

  function updateTextIndicators(newShowValue, newFadeValue) {
    showTextIndicators = newShowValue !== false;
    fadeTextIndicators = newFadeValue === true;
    const lineBoxes = document.querySelectorAll('.line-box');
    lineBoxes.forEach(lineBox => {
      applyIndicatorBoxStyles(lineBox);
    });
  }

  ipcRenderer.on("new-fontsize", (event, newsize) => {
    textEl.style.fontSize = `${newsize}px`;
  })
  ipcRenderer.on("new-weburl1", (event, newurl) => {
    console.log("yes")
    setupWebSocket(newurl, true)
  })
  ipcRenderer.on("new-weburl2", (event, newurl) => {
    setupWebSocket(newurl, false)
  })
  ipcRenderer.on("new-hideonstartup", (event, newValue) => {
    hideOnStartup = newValue;
  })

  ipcRenderer.on('show-overlay-hotkey', (event, isActive) => {
    manualHotkeyPressed = isActive;
    if (manualHotkeyPressed) {
      manualModeActivatedOnce = true;
      document.body.classList.add('force-visible');
      showTextBoxes();
      ipcRenderer.send('set-ignore-mouse-events', false);
    } else {
      // Always set manualHotkeyPressed to false even if Yomitan is showing
      // to maintain consistent state
      if (yomitanShowing) {
        hideOnYomitanClose = true;
        // Don't return early - still need to remove force-visible if not pinned
        if (!pinned) {
          document.body.classList.remove('force-visible');
        }
        return;
      }
      if (!pinned) {
        document.body.classList.remove('force-visible');
      }
      hideTextBoxes();
      ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
    }
  });

  // Dedicated AFK hide channel ‚Äî main process sends this when AFK timeout occurs
  ipcRenderer.on('afk-hide', (event, shouldHide) => {
    if (shouldHide) {
      // Mirror the hotkey release behavior but mark it as AFK-driven
      manualHotkeyPressed = false;
      if (!pinned) {
        document.body.classList.remove('force-visible');
      }
      hideTextBoxes();
      // Tell main to ignore mouse events so clicks pass through
      ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
    } else {
      // show overlay again
      document.body.classList.add('force-visible');
      showTextBoxes();
    }
  });

  ipcRenderer.on("force-visible", (event, value) => {
    if (!pinned) {
      if (value) {
        document.body.classList.add("force-visible");
      } else {
        document.body.classList.remove("force-visible");
      }
    }
  });

  // Toggle furigana visibility on hotkey
  let furiganaVisible = true;
  let hideFuriganaOnStartup = true; // default to true
  
  ipcRenderer.on("toggle-furigana-visibility", () => {
    furiganaVisible = !furiganaVisible;
    const furiganaBoxes = document.querySelectorAll('.furigana-box');
    furiganaBoxes.forEach(box => {
      box.style.display = furiganaVisible ? 'block' : 'none';
    });
  });

  // Toggle translation visibility on hotkey
  ipcRenderer.on("toggle-translation-visibility", () => {
    const translationDiv = document.getElementById('translation-display');
    if (translationDiv) {
      const isVisible = translationDiv.style.display !== 'none';
      translationDiv.style.display = isVisible ? 'none' : 'block';
    }
  });

  ipcRenderer.on("request-current-settings", () => {
    const fontSize = parseInt(textEl.style.fontSize, 10);
    const weburl1 = overlaySocketUrls.ws1;
    const weburl2 = overlaySocketUrls.ws2;
    ipcRenderer.send("reply-current-settings", {
      fontSize,
      weburl1,
      weburl2,
      hideOnStartup,
      showHotkey,
      manualMode,
      showTextIndicators,
      fadeTextIndicators,
      hideFuriganaOnStartup
    });
  })

  ipcRenderer.on('toggle-main-box', () => {
    const mainBox = document.getElementById('main-box');
    if (mainBox.style.display === 'none') {
      mainBox.style.display = '';
    } else {
      mainBox.style.display = 'none';
    }
  });

  ipcRenderer.on('magpie-window-info', (event, info) => {
    // DEPRECATED: Now receiving magpie info via websocket in window_state messages
    // Keeping this handler for backwards compatibility but not using it
    console.log('Received Magpie window info via IPC (deprecated):', info);
  });

  ipcRenderer.on('new-manualmode', (event, newValue) => {
    updateManualMode(newValue);
  });

  // Listen for game state changes to control action panel visibility
  ipcRenderer.on('game-state', (event, state) => {
    /*
    const actionPanelTrigger = document.getElementById('action-panel-trigger');
    const actionPanel = document.getElementById('action-panel');
    
    if (state === 'active') {
      // Game is active - show action panel trigger
      if (actionPanelTrigger) actionPanelTrigger.style.display = 'flex';
      console.log('Game active - showing action panel trigger');
    } else {
      // Game is background, obscured, minimized, or closed - hide action panel
      if (actionPanelTrigger) actionPanelTrigger.style.display = 'none';
      if (actionPanel) actionPanel.classList.remove('visible', 'startup-hint');
      console.log(`Game ${state} - hiding action panel`);
    }
    */
  });

  // Handle translation results
  ipcRenderer.on('translation-received', (event, translation) => {
    console.log('Translation received:', translation);
    showTranslation(translation);
  });

  ipcRenderer.on('translation-error', (event, error) => {
    console.error('Translation error:', error);
    showTranslation('Translation failed: ' + error);
  });

  // Handle manual mode recommendation
  ipcRenderer.on('recommend-manual-mode', (event, { game }) => {
    if (dismissedRecommendationGames.includes(game)) {
      // User already dismissed for this game permanently
      return;
    }
    
    currentGameForRecommendation = game;
    const banner = document.getElementById('manual-mode-recommendation');
    if (banner) {
      banner.classList.add('visible');
    }
  });

  // Handle enabling manual mode from recommendation
  document.addEventListener('DOMContentLoaded', () => {
    const enableBtn = document.getElementById('btn-enable-manual');
    const dismissBtn = document.getElementById('btn-dismiss-recommendation');
    const banner = document.getElementById('manual-mode-recommendation');

    if (enableBtn) {
      enableBtn.addEventListener('click', () => {
        // Enable manual mode
        ipcRenderer.send('setting-changed', { key: 'manualMode', value: true });
        // Hide banner
        if (banner) banner.classList.remove('visible');
        // Save dismissed game permanently
        if (currentGameForRecommendation && !dismissedRecommendationGames.includes(currentGameForRecommendation)) {
          dismissedRecommendationGames.push(currentGameForRecommendation);
          ipcRenderer.send('setting-changed', { key: 'dismissedFullscreenRecommendations', value: dismissedRecommendationGames });
        }
      });
    }

    if (dismissBtn) {
      dismissBtn.addEventListener('click', () => {
        // Permanently dismiss for this game
        if (banner) banner.classList.remove('visible');
        if (currentGameForRecommendation && !dismissedRecommendationGames.includes(currentGameForRecommendation)) {
          dismissedRecommendationGames.push(currentGameForRecommendation);
          ipcRenderer.send('setting-changed', { key: 'dismissedFullscreenRecommendations', value: dismissedRecommendationGames });
        }
      });
    }
  });

  // Function to display translation over text boxes
  function showTranslation(translationText) {
    // Remove any existing translation
    const existingTranslation = document.getElementById('translation-display');
    if (existingTranslation) {
      existingTranslation.remove();
    }

    if (!translationText) return;

    // Get all text boxes to calculate their bounding area
    const textBoxes = document.querySelectorAll('.text-box');
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    textBoxes.forEach(box => {
      if (box.style.display !== 'none') {
        const rect = box.getBoundingClientRect();
        minX = Math.min(minX, rect.left);
        minY = Math.min(minY, rect.top);
        maxX = Math.max(maxX, rect.right);
        maxY = Math.max(maxY, rect.bottom);
      }
    });

    // Create translation display element
    const translationDiv = document.createElement('div');
    translationDiv.id = 'translation-display';
    translationDiv.style.position = 'absolute';
    
    // Position over the text boxes if they exist, otherwise use a default position
    if (textBoxes.length > 0 && minX !== Infinity) {
      translationDiv.style.left = `${minX}px`;
      translationDiv.style.top = `${minY}px`;
      translationDiv.style.width = `${maxX - minX}px`;
      translationDiv.style.height = `${maxY - minY}px`;
    } else {
      // Fallback to center area if no text boxes
      translationDiv.style.left = '50%';
      translationDiv.style.top = '50%';
      translationDiv.style.transform = 'translate(-50%, -50%)';
    }
    
    translationDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.97)';
    translationDiv.style.color = 'white';
    translationDiv.style.padding = '20px 30px';
    translationDiv.style.borderRadius = '10px';
    translationDiv.style.border = '2px solid rgba(0, 255, 136, 0.5)';
    translationDiv.style.boxShadow = '0 0 20px rgba(0, 255, 136, 0.3)';
    // Set font size based on .text-box font size, or fallback to 24px
    let sampleBox = document.querySelector('.text-box');
    let fontSize = 32;
    if (sampleBox) {
      const computed = window.getComputedStyle(sampleBox);
      fontSize = parseInt(computed.fontSize) - Math.floor(parseInt(computed.fontSize) * 0.2) || 32;
    }
    translationDiv.style.fontSize = fontSize + 'px';
    translationDiv.style.maxWidth = '80%';
    translationDiv.style.textAlign = 'center';
    translationDiv.style.zIndex = '10001';
    translationDiv.style.pointerEvents = 'none';
    translationDiv.style.userSelect = 'none';
    translationDiv.style.whiteSpace = 'pre-wrap';
    translationDiv.style.wordBreak = 'break-word';
    translationDiv.textContent = translationText;
    translationDiv.style.transition = 'opacity 0.3s ease';

    document.body.appendChild(translationDiv);

    // Hide on hover to see text underneath
    const hideOnHover = () => {
      if (translationDiv && translationDiv.parentNode) {
        translationDiv.style.opacity = '0';
      }
    };

    const showOnHoverEnd = () => {
      if (translationDiv && translationDiv.parentNode) {
        translationDiv.style.opacity = '1';
      }
    };

    document.body.addEventListener('mouseenter', hideOnHover);
    document.body.addEventListener('mouseleave', showOnHoverEnd);

    // Auto-remove after 30 seconds
    // setTimeout(() => {
    //   if (translationDiv && translationDiv.parentNode) {
    //     document.body.removeEventListener('mouseenter', hideOnHover);
    //     document.body.removeEventListener('mouseleave', showOnHoverEnd);
    //     translationDiv.remove();
    //   }
    // }, 30000);
  }

</script>

<!-- Gamepad Handler Script -->
<script src="gamepad.js"></script>
<script>
  // ==================== Gamepad Integration ====================
  // This provides controller support for navigating text blocks and cursor positions
  // to enable Yomitan lookups without a mouse.
  // 
  // IMPORTANT: This uses a Python WebSocket server (overlay_server.py) to handle
  // gamepad input at the OS level, allowing it to work even when another window
  // (like a game) has focus. The browser Gamepad API doesn't work when unfocused.
  
  let gamepadHandler = null;
  let gamepadSettings = {
    enabled: true,
    serverUrl: 'ws://localhost:55003', // Python gamepad server
    activationMode: 'modifier', // 'modifier' or 'toggle'
    modifierButton: 4, // LB
    toggleButton: 8, // Back/Select
    confirmButton: 0, // A
    cancelButton: 1, // B
    repeatDelay: 400,
    repeatRate: 150,
    showIndicator: true,
    tokenMode: false, // Navigate by MeCab tokens (words) instead of characters
    tokenizerBackend: 'mecab', // "mecab" or "yomitan-api"
    yomitanApiUrl: 'http://127.0.0.1:19633', // Base URL for Yomitan API
    yomitanScanLength: 10, // scanLength for Yomitan /tokenize
    controllerEnabled: true, // Enable controller button activation
    keyboardEnabled: true, // Enable keyboard hotkey activation (set from settings)
  };
  
  // Initialize gamepad handler
  function initGamepad() {
    if (gamepadHandler) {
      gamepadHandler.destroy();
    }
    
    gamepadHandler = new GamepadHandler({
      serverUrl: gamepadSettings.serverUrl,
      activationMode: gamepadSettings.activationMode,
      modifierButton: gamepadSettings.modifierButton,
      toggleButton: gamepadSettings.toggleButton,
      confirmButton: gamepadSettings.confirmButton,
      cancelButton: gamepadSettings.cancelButton,
      repeatDelay: gamepadSettings.repeatDelay,
      repeatRate: gamepadSettings.repeatRate,
      showIndicator: gamepadSettings.showIndicator,
      tokenMode: gamepadSettings.tokenMode,
      tokenizerBackend: gamepadSettings.tokenizerBackend,
      yomitanApiUrl: gamepadSettings.yomitanApiUrl,
      yomitanScanLength: gamepadSettings.yomitanScanLength,
      controllerEnabled: gamepadSettings.controllerEnabled,
      keyboardEnabled: gamepadSettings.keyboardEnabled,
      
      // Callbacks
      onBlockChange: (data) => {
        console.log('[Gamepad] Block changed:', data.blockIndex, '/', data.totalBlocks);
        updateGamepadStatusIndicator();
        // Notify main process
        ipcRenderer.send('gamepad-block-change', data.blockIndex);
      },
      
      onCursorChange: (data) => {
        console.log('[Gamepad] Cursor changed:', data.cursorIndex, '/', data.totalCharacters);
        updateGamepadStatusIndicator();
        if (data.character) {
          console.log('[Gamepad] Current character:', data.character.textContent);
        }
      },
      
      onModeChange: (data) => {
        console.log('[Gamepad] Navigation mode:', data.active ? 'ACTIVE' : 'INACTIVE');
        updateGamepadStatusIndicator();
        ipcRenderer.send('gamepad-navigation-state', { active: !!data.active });
        
        // While in controller navigation mode, disable click-through so focus/z-order is stable.
        // Main process restores click-through on exit only when it is safe.
        if (data.active) {
          ipcRenderer.send('set-ignore-mouse-events', false, { forward: true });
        }
      },
      
      onButtonPress: (data) => {
        // Forward all button presses to main process for potential custom handling
        ipcRenderer.send('gamepad-button', data);
      },
      
      onConfirm: (data) => {
        console.log('[Gamepad] Confirmed selection:', data.character);
        // The click event dispatched by GamepadHandler should trigger Yomitan
      },
      
      onCancel: () => {
        console.log('[Gamepad] Selection cancelled');
      },
      
      onConnectionChange: (data) => {
        console.log('[Gamepad] Server connection:', data.connected ? 'CONNECTED' : 'DISCONNECTED');
        updateGamepadStatusIndicator();
      },
    });
    
    console.log('[Gamepad] Handler initialized - connecting to Python server at', gamepadSettings.serverUrl);
  }
  
  // Update gamepad status indicator
  function updateGamepadStatusIndicator() {
    const statusEl = document.getElementById('gamepad-status');
    if (!statusEl || !gamepadHandler) return;
    
    const state = gamepadHandler.getCurrentState();
    const serverConnected = gamepadHandler.isServerConnected();
    const gamepadConnected = gamepadHandler.isGamepadConnected();

    statusEl.classList.toggle('connected', serverConnected && gamepadConnected);
    statusEl.classList.toggle('server-connected', serverConnected);
    statusEl.classList.toggle('active', state.isActive);
    
    if (!serverConnected) {
      statusEl.textContent = 'üéÆ Server disconnected - start overlay_server.py';
      statusEl.style.display = 'block';
      statusEl.style.color = '#ff6b6b';
    } else if (!gamepadConnected) {
      statusEl.textContent = 'üéÆ No controller detected';
      statusEl.style.display = 'block';
      statusEl.style.color = '#ffd43b';
    } else if (state.isActive) {
      const modeLabel = state.tokenMode && state.totalTokens > 0 ? 'Token' : 'Char';
      const totalUnits = state.tokenMode && state.totalTokens > 0 ? state.totalTokens : state.totalCharacters;
      statusEl.textContent = `üéÆ Navigation: Block ${state.currentBlockIndex + 1}/${state.totalBlocks} | ${modeLabel} ${state.currentCursorIndex + 1}/${totalUnits}`;
      statusEl.style.display = 'block';
      statusEl.style.color = '#00ff88';
    } else {
      statusEl.textContent = 'üéÆ Controller ready (hold LB + D-Pad to navigate)';
      statusEl.style.display = 'block';
      statusEl.style.color = '#00ff88';
    }
    
    // Auto-hide after 5 seconds if not in active mode
    if (!state.isActive) {
      setTimeout(() => {
        if (gamepadHandler && !gamepadHandler.getCurrentState().isActive) {
          const el = document.getElementById('gamepad-status');
          if (el && !el.classList.contains('active')) {
            el.style.display = 'none';
          }
        }
      }, 5000);
    }
  }
  
  // Listen for server connection events
  window.addEventListener('gsm-gamepad-server-connected', () => {
    console.log('[Gamepad] Server connected');
    updateGamepadStatusIndicator();
  });
  
  window.addEventListener('gsm-gamepad-server-disconnected', () => {
    console.log('[Gamepad] Server disconnected');
    updateGamepadStatusIndicator();
  });
  
  // Listen for gamepad connection events
  window.addEventListener('gsm-gamepad-connected', (e) => {
    console.log('[Gamepad] Controller connected:', e.detail.device);
    updateGamepadStatusIndicator();
    ipcRenderer.send('gamepad-connected', e.detail);
  });
  
  window.addEventListener('gsm-gamepad-disconnected', (e) => {
    console.log('[Gamepad] Controller disconnected:', e.detail.device);
    updateGamepadStatusIndicator();
    ipcRenderer.send('gamepad-disconnected', e.detail);
  });
  
  // Listen for navigation activation
  window.addEventListener('gsm-gamepad-navigation-active', (e) => {
    updateGamepadStatusIndicator();
  });
  
  // Listen for cursor position changes (for debugging/visualization)
  window.addEventListener('gsm-gamepad-cursor-position', (e) => {
    // This event fires whenever the gamepad moves the cursor
    // The GamepadHandler already handles positioning, but we can add
    // additional logic here if needed
  });
  
  // IPC: Receive gamepad settings from main process
  ipcRenderer.on('gamepad-settings', (event, settings) => {
    console.log('[Gamepad] Settings received:', settings);
    gamepadSettings = { ...gamepadSettings, ...settings };
    
    if (gamepadHandler) {
      gamepadHandler.updateConfig(gamepadSettings);
    }
  });
  
  // IPC: Toggle gamepad navigation mode (can be triggered by hotkey from main)
  ipcRenderer.on('gamepad-toggle-navigation', () => {
    if (gamepadHandler) {
      gamepadHandler.manualToggle();
    }
  });
  
  // IPC: Manual navigation commands (can be bound to keyboard in main)
  ipcRenderer.on('gamepad-navigate', (event, direction) => {
    if (!gamepadHandler) return;
    
    switch (direction) {
      case 'up':
        gamepadHandler.manualBlockUp();
        break;
      case 'down':
        gamepadHandler.manualBlockDown();
        break;
      case 'left':
        gamepadHandler.manualCursorLeft();
        break;
      case 'right':
        gamepadHandler.manualCursorRight();
        break;
      case 'activate':
        gamepadHandler.manualActivate();
        break;
      case 'deactivate':
        gamepadHandler.manualDeactivate();
        break;
    }
    
    updateGamepadStatusIndicator();
  });
  
  // Listen for token mode changes and save to settings
  window.addEventListener('gsm-gamepad-token-mode-changed', (e) => {
    console.log('[Gamepad] Token mode changed:', e.detail.tokenMode);
    gamepadSettings.tokenMode = e.detail.tokenMode;
    // Save to persistent settings via IPC
    ipcRenderer.send('save-settings', { gamepadTokenMode: e.detail.tokenMode });
    updateGamepadStatusIndicator();
  });
  
  // Initialize gamepad after DOM is ready
  // NOTE: Don't initialize immediately - wait for settings to be loaded first
  // Settings are sent via 'load-settings' event after window is ready
  // if (document.readyState === 'loading') {
  //   document.addEventListener('DOMContentLoaded', initGamepad);
  // } else {
  //   initGamepad();
  // }
  
  // Re-initialize when settings change
  ipcRenderer.on('settings-updated', (event, updatedSettings) => {
    let needsReinit = false;
    
    // Handle server URL change
    if (updatedSettings.gamepadServerPort !== undefined) {
      gamepadSettings.serverUrl = `ws://localhost:${updatedSettings.gamepadServerPort}`;
      needsReinit = true;
    }
    
    if (updatedSettings.gamepadEnabled !== undefined) {
      gamepadSettings.enabled = updatedSettings.gamepadEnabled;
      needsReinit = true;
    }
    if (updatedSettings.gamepadActivationMode !== undefined) {
      gamepadSettings.activationMode = updatedSettings.gamepadActivationMode;
      needsReinit = true;
    }
    if (updatedSettings.gamepadModifierButton !== undefined) {
      gamepadSettings.modifierButton = updatedSettings.gamepadModifierButton;
      if (gamepadHandler) gamepadHandler.updateConfig({ modifierButton: updatedSettings.gamepadModifierButton });
    }
    if (updatedSettings.gamepadToggleButton !== undefined) {
      gamepadSettings.toggleButton = updatedSettings.gamepadToggleButton;
      if (gamepadHandler) gamepadHandler.updateConfig({ toggleButton: updatedSettings.gamepadToggleButton });
    }
    if (updatedSettings.gamepadConfirmButton !== undefined) {
      gamepadSettings.confirmButton = updatedSettings.gamepadConfirmButton;
      if (gamepadHandler) gamepadHandler.updateConfig({ confirmButton: updatedSettings.gamepadConfirmButton });
    }
    if (updatedSettings.gamepadCancelButton !== undefined) {
      gamepadSettings.cancelButton = updatedSettings.gamepadCancelButton;
      if (gamepadHandler) gamepadHandler.updateConfig({ cancelButton: updatedSettings.gamepadCancelButton });
    }
    if (updatedSettings.gamepadShowIndicator !== undefined) {
      gamepadSettings.showIndicator = updatedSettings.gamepadShowIndicator;
      if (gamepadHandler) gamepadHandler.updateConfig({ showIndicator: updatedSettings.gamepadShowIndicator });
    }
    if (updatedSettings.gamepadTokenMode !== undefined) {
      gamepadSettings.tokenMode = updatedSettings.gamepadTokenMode;
      if (gamepadHandler) gamepadHandler.setTokenMode(updatedSettings.gamepadTokenMode);
    }
    if (updatedSettings.gamepadTokenizerBackend !== undefined) {
      gamepadSettings.tokenizerBackend = updatedSettings.gamepadTokenizerBackend;
      if (gamepadHandler) gamepadHandler.updateConfig({ tokenizerBackend: updatedSettings.gamepadTokenizerBackend });
    }
    if (updatedSettings.gamepadYomitanApiUrl !== undefined) {
      gamepadSettings.yomitanApiUrl = updatedSettings.gamepadYomitanApiUrl;
      if (gamepadHandler) gamepadHandler.updateConfig({ yomitanApiUrl: updatedSettings.gamepadYomitanApiUrl });
    }
    if (updatedSettings.gamepadYomitanScanLength !== undefined) {
      gamepadSettings.yomitanScanLength = updatedSettings.gamepadYomitanScanLength;
      if (gamepadHandler) gamepadHandler.updateConfig({ yomitanScanLength: updatedSettings.gamepadYomitanScanLength });
    }
    if (updatedSettings.gamepadControllerEnabled !== undefined) {
      gamepadSettings.controllerEnabled = updatedSettings.gamepadControllerEnabled;
      if (gamepadHandler) gamepadHandler.updateConfig({ controllerEnabled: updatedSettings.gamepadControllerEnabled });
    }
    if (updatedSettings.gamepadKeyboardEnabled !== undefined) {
      gamepadSettings.keyboardEnabled = updatedSettings.gamepadKeyboardEnabled;
      if (gamepadHandler) gamepadHandler.updateConfig({ keyboardEnabled: updatedSettings.gamepadKeyboardEnabled });
    }
    if (updatedSettings.gamepadRepeatDelay !== undefined) {
      gamepadSettings.repeatDelay = updatedSettings.gamepadRepeatDelay;
      if (gamepadHandler) gamepadHandler.updateConfig({ repeatDelay: updatedSettings.gamepadRepeatDelay });
    }
    if (updatedSettings.gamepadRepeatRate !== undefined) {
      gamepadSettings.repeatRate = updatedSettings.gamepadRepeatRate;
      if (gamepadHandler) gamepadHandler.updateConfig({ repeatRate: updatedSettings.gamepadRepeatRate });
    }
    
    // Re-initialize handler if needed
    if (needsReinit) {
      if (gamepadSettings.enabled) {
        initGamepad();
      } else if (gamepadHandler) {
        gamepadHandler.destroy();
        gamepadHandler = null;
      }
    }
  });
  
  // Expose for debugging
  window.getGamepadState = () => gamepadHandler ? gamepadHandler.getCurrentState() : null;
  window.gamepadHandler = gamepadHandler;
</script>

</html>
