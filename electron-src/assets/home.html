<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Controller</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <!-- Include shared module with ipcRenderer, clipboard, and sharedState -->
    <script src="shared.js"></script>

    <div class="card">
        <h2>Game Capture (Required)</h2>
        <div class="input-group">
            <label for="sceneSelect">Game:</label>
            <select id="sceneSelect"></select>
            <button id="refreshScenesBtn">&#x21bb;</button>
            <button id="removeSceneBtn" class="danger">Remove Game</button>
        </div>
        <div class="input-group">
            <label for="windowSelect">Setup New Game:</label>
            <select id="windowSelect"></select>
            <button id="refreshWindowsBtn">&#x21bb;</button>
            <button id="createNewSceneBtn" style="width: 300px">Window Capture</button>
            <button id="createNewSceneGameBtn" style="width: 300px">Game Capture</button>
            <span class="tooltip tooltip-left">‚ùì
                <span class="tooltiptext">
                    Window Capture works for most applications
                    <br>
                    Game Capture is recommended for fullscreen games.
                    <br>
                    If not on Windows, you need to setup OBS Scenes manually.
                </span>
            </span>
        </div>
    </div>
    <div class="card">
        <div class="grid-container">
            <div class="grid-container">
                <div class="input-group">
                    <button id="openGSMSettingsBtn" style="width: 100%;">Open GSM Settings</button>
                </div>
                <div class="input-group">
                    <button id="runOverlayBtn" style="width: 100%;">Run Overlay</button>
                    <button id="open-overlay-wiki-btn" class="secondary">
                        <span style="font-size: 14px;">‚ùì</span>
                    </button>
                    <script>
                        document.getElementById('open-overlay-wiki-btn').addEventListener('click', () => {
                            window.open('https://github.com/bpwhelan/GameSentenceMiner/wiki/Overlay-%E2%80%90-Overview', '_blank');
                        });
                    </script>
                </div>
            </div>
        </div>
    </div>
    <div class="card">
        <h2>Status:</h2>
        <div class="grid-container">
            <button class="status-button card" id="gsm-status"
                title="GSM Status: Indicates whether the GSM Python app is running.">
                <span class="icon">‚õè</span> <span>GSM</span> <span></span>
            </button>
            <button class="status-button card" id="clipboard-status"
                title="Clipboard Status: Indicates whether the clipboard is being monitored.">
                <span class="icon">üìã</span> <span>Clipboard</span> <span></span>
            </button>
            <span id="websocket_container" class="grid-container">
            </span>
            <button class="status-button card" id="obs-status" title="OBS Status: Indicates whether OBS is running."
                style="pointer-events: auto; cursor: pointer;">
                <span class="icon">üìπ</span> <span>OBS</span> <span></span>
            </button>
            <button class="status-button card" id="anki-status"
                title="Anki Status: Indicates whether Anki is connected.">
                <span class="icon">üìò</span> <span>Anki</span> <span></span>
            </button>
        </div>
    </div>
    <div class="card">
        <h2>Support GSM Development</h2>
        <p style="margin-bottom: 15px; color: #afacac; font-size: 14px; text-align: center;">
            GSM will always be free, but a lot of work goes into maintaining and improving it. If you've found this
            project helpful in any way, please consider supporting continued development:
        </p>
        <div class="donation-links" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <a href="#" onclick="openExternalLink('https://github.com/sponsors/bpwhelan')" class="donation-link"
                style="display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: #24292e; color: white; text-decoration: none; border-radius: 6px; font-size: 14px; transition: background-color 0.2s;"
                onmouseover="this.style.backgroundColor='#1a1e22'" onmouseout="this.style.backgroundColor='#24292e'">
                <span style="font-size: 16px;">üíñ</span>
                <span>GitHub Sponsors</span>
            </a>
            <a href="#" onclick="openExternalLink('https://ko-fi.com/beangate')" class="donation-link"
                style="display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: #ff5722; color: white; text-decoration: none; border-radius: 6px; font-size: 14px; transition: background-color 0.2s;"
                onmouseover="this.style.backgroundColor='#e64a19'" onmouseout="this.style.backgroundColor='#ff5722'">
                <span style="font-size: 16px;">‚òï</span>
                <span>Ko-fi</span>
            </a>
            <!-- <a href="#" onclick="openExternalLink('https://www.patreon.com/GameSentenceMiner')" class="donation-link" style="display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: #f96854; color: white; text-decoration: none; border-radius: 6px; font-size: 14px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#e5452f'" onmouseout="this.style.backgroundColor='#f96854'">
            <span style="font-size: 16px;">üéØ</span>
            <span>Patreon</span>
        </a> -->
            <!-- <a href="#" onclick="openExternalLink('https://github.com/bpwhelan/GameSentenceMiner')"
                class="donation-link"
                style="display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: #4078c0; color: white; text-decoration: none; border-radius: 6px; font-size: 14px; transition: background-color 0.2s;"
                onmouseover="this.style.backgroundColor='#365e9d'" onmouseout="this.style.backgroundColor='#4078c0'">
                <span style="font-size: 16px;">‚≠ê</span>
                <span>Star on GitHub (Free)</span>
            </a> -->
        </div>
    </div>
    <script>
        const removeSceneBtn = document.getElementById('removeSceneBtn');
        const openGSMSettingsBtn = document.getElementById('openGSMSettingsBtn');
        const runOverlayBtn = document.getElementById('runOverlayBtn');
        const obsStatusBtn = document.getElementById('obs-status');
        const sceneSelect = document.getElementById('sceneSelect');
        const windowSelect = document.getElementById('windowSelect');
        let windows = [];


        obsStatusBtn.addEventListener('click', async () => {
            console.log("Opening OBS");
            await ipcRenderer.invoke('openOBS');
        });

        function openExternalLink(url) {
            ipcRenderer.invoke('open-external-link', url);
        }

        document.getElementById('sceneSelect').addEventListener('change', (event) => {
            ipcRenderer.invoke('obs.switchScene.id', event.target.value);
            if (event.target.value === "GSM HELPER") {
                removeSceneBtn.disabled = true;
            } else {
                removeSceneBtn.disabled = false;
            }
        });

        openGSMSettingsBtn.addEventListener('click', async () => {
            console.log("Opening GSM Settings");
            await ipcRenderer.invoke('settings.openGSMSettings');
        });

        runOverlayBtn.addEventListener('click', async () => {
            console.log("Running Overlay");
            await ipcRenderer.invoke('runOverlay');
        });

        function getWindows(showLoading = true) {
            if (isWindows === false) {
                return;
            }
            // Remember the previously selected window
            const previousSelection = windowSelect.value;

            if (showLoading)
                windowSelect.innerHTML = '<option>Loading...</option>';

            ipcRenderer.invoke('obs.getWindows').then(windowsRes => {
                windows = windowsRes;
                windowSelect.innerHTML = '';
                windows.forEach(window => {
                    const option = document.createElement('option');
                    option.value = window.value;
                    option.textContent = window.title;
                    windowSelect.appendChild(option);
                });

                // Restore previous selection if it still exists in the list (compare by value)
                if (previousSelection && windows.some(w => w.value === previousSelection)) {
                    windowSelect.value = previousSelection;
                }
                windows = windowsRes;
            });
        }

        function refreshScenesAndWindows(showLoading = true, setIntervalFlag = true) {
            // Remember the previously selected scene
            if (showLoading)
                sceneSelect.innerHTML = '<option>Loading...</option>';
            const previousSelection = sceneSelect.value;
            ipcRenderer.invoke('obs.getScenes').then(obsScenes => {
                scenes = obsScenes;
                sceneSelect.innerHTML = '';
                scenes.forEach(scene => {
                    const option = document.createElement('option');
                    option.value = scene.id;
                    option.textContent = scene.name;
                    sceneSelect.appendChild(option);
                });
                // Restore previous selection if it still exists in the list
                if (previousSelection && scenes.some(s => s.id === previousSelection)) {
                    sceneSelect.value = previousSelection;
                } else {
                    sceneSelect.selectedIndex = 0;
                }

                ipcRenderer.invoke('obs.getActiveScene').then(activeScene => {
                    if (activeScene) {
                        if (scenes.some(s => s.id === activeScene.id)) {
                            sceneSelect.value = activeScene.id;
                        }
                    }
                });
                getWindows(showLoading);
            });
            if (setIntervalFlag)
                setInterval(() => refreshScenesAndWindows(false, false), 5000);
        }

        document.getElementById('refreshScenesBtn').addEventListener('click', () => {
            getScenes();
        });

        removeSceneBtn.addEventListener('click', () => {
            ipcRenderer.invoke('obs.removeScene', document.getElementById('sceneSelect').value);
            getScenes();
        });

        document.getElementById('windowSelect').addEventListener('change', (event) => {
            const selectedWindow = document.getElementById('windowSelect').selectedOptions[0];
            const windowData = {
                title: selectedWindow.textContent,
                path: selectedWindow.value
            };
        });

        document.getElementById('refreshWindowsBtn').addEventListener('click', () => {
            getWindows();
        });

        document.getElementById('createNewSceneBtn').addEventListener('click', () => {
            const selectedWindow = document.getElementById('windowSelect').selectedOptions[0];
            const windowDataFromOBS = windows.filter(w => w.value === selectedWindow.value);
            console.log(selectedWindow)
            const windowData = {
                title: selectedWindow.textContent,
                value: selectedWindow.value,
                sceneName: selectedWindow.textContent,
                captureSource: windowDataFromOBS[0].captureMode || 'window',
            };
            console.log(windowData)
            ipcRenderer.invoke('obs.createScene', windowData);
        })

        document.getElementById('createNewSceneGameBtn').addEventListener('click', () => {
            const selectedWindow = document.getElementById('windowSelect').selectedOptions[0];
            console.log(selectedWindow)
            const windowData = {
                title: selectedWindow.textContent,
                value: selectedWindow.value,
                sceneName: selectedWindow.textContent,
            };
            console.log(windowData)
            ipcRenderer.invoke('obs.createScene.Game', windowData);
        })

        const gsmStatusButton = document.getElementById('gsm-status');
        const websocketContainer = document.getElementById('websocket_container');
        const obsStatus = document.getElementById('obs-status');
        const ankiStatus = document.getElementById('anki-status');
        const clipboardStatus = document.getElementById('clipboard-status');
        let ws_showing = {};


        setInterval(() => {
            ipcRenderer.invoke('get_gsm_status').then(gsmStatus => {
                if (gsmStatus === null) {
                    gsmStatusButton.classList.toggle('red', true);
                    gsmStatusButton.classList.toggle('green', false);
                    gsmStatusButton.querySelector('span:last-child').textContent = "Installing/Initializing";
                    return;
                }
                const ready = gsmStatus.ready;
                const status = gsmStatus.status;
                const websockets_connected = gsmStatus.websockets_connected;
                const obs_connected = gsmStatus.obs_connected;
                const anki_connected = gsmStatus.anki_connected;
                const last_line_received = gsmStatus.last_line_received;
                const words_being_processed = gsmStatus.words_being_processed;
                const clipboard_enabled = gsmStatus.clipboard_enabled;
                const anyWebsocketsConnected = websockets_connected.length > 0;

                // Update GSM status
                gsmStatusButton.classList.toggle('green', ready);
                gsmStatusButton.classList.toggle('red', !ready);
                gsmStatusButton.querySelector('span:last-child').textContent = ready ? `${status}` : 'GSM is not running';
                if (words_being_processed.length > 0) {
                    gsmStatusButton.querySelector('span:last-child').textContent = `Processing: ${words_being_processed}`;
                }
                const timeDifference = Math.floor((Date.now() - new Date(last_line_received).getTime()) / 1000);
                let relativeTime = '';
                if (!last_line_received) {
                    relativeTime = 'Not received yet';
                } else if (isNaN(timeDifference)) {
                    relativeTime = 'Not received yet';
                } else if (timeDifference < 60) {
                    relativeTime = `${timeDifference} seconds ago`;
                } else if (timeDifference < 3600) {
                    relativeTime = `${Math.floor(timeDifference / 60)} minutes ago`;
                } else if (timeDifference < 86400) {
                    relativeTime = `${Math.floor(timeDifference / 3600)} hours ago`;
                } else {
                    relativeTime = `${Math.floor(timeDifference / 86400)} days ago`;
                }

                gsmStatusButton.setAttribute('title', ready ? `Status: ${status}\nWebSockets: ${websockets_connected.length > 0 ? websockets_connected.join(', ') : 'None'}\nOBS: ${obs_connected ? 'Started' : 'Stopped'}\nAnki: ${anki_connected ? 'Connected' : 'Disconnected'}\nLast Line Received: ${relativeTime}` : 'GSM is stopped.');

                // Update Clipboard status
                clipboardStatus.classList.toggle('green', clipboard_enabled);
                clipboardStatus.classList.toggle('red', !clipboard_enabled);
                clipboardStatus.classList.toggle('neutral', !clipboard_enabled && anyWebsocketsConnected);
                clipboardStatus.querySelector('span:last-child').textContent = clipboard_enabled ? 'Enabled' : 'Disabled';
                clipboardStatus.setAttribute('title', clipboard_enabled ? 'Clipboard monitoring is enabled.' : 'Clipboard monitoring is disabled.');

                // Update WebSocket status buttons
                websockets_connected.forEach(ws => {
                    if (!ws_showing[ws]) {
                        const wsButton = document.createElement('button');
                        wsButton.className = 'status-button card'; // Add card class for styling
                        wsButton.id = `ws-${ws.replace(/[^a-zA-Z0-9]/g, '-')}`; // Create a valid ID
                        wsButton.innerHTML = `<span class="icon">üîó</span> <span>${ws}</span> <span></span>`; // Use link icon for WebSocket
                        websocketContainer.appendChild(wsButton);
                        ws_showing[ws] = wsButton;
                    }
                    const currentWsButton = ws_showing[ws];
                    currentWsButton.classList.toggle('green', true); // WebSockets listed are always connected
                    currentWsButton.classList.toggle('red', false);
                    currentWsButton.querySelector('span:last-child').textContent = 'Connected';
                    currentWsButton.setAttribute('title', `${ws} is connected.`);
                });

                // Remove buttons for disconnected WebSockets
                Object.keys(ws_showing).forEach(ws => {
                    if (!websockets_connected.includes(ws)) {
                        websocketContainer.removeChild(ws_showing[ws]);
                        delete ws_showing[ws];
                    }
                });

                // Update OBS status
                obsStatus.classList.toggle('green', obs_connected);
                obsStatus.classList.toggle('red', !obs_connected);
                obsStatus.querySelector('span:last-child').textContent = obs_connected ? 'Connected' : 'Disconnected';
                obsStatus.setAttribute('title', obs_connected ? 'OBS is connected.' : 'OBS is disconnected.');


                // Update Anki status
                ankiStatus.classList.toggle('green', anki_connected);
                ankiStatus.classList.toggle('red', !anki_connected);
                ankiStatus.querySelector('span:last-child').textContent = anki_connected ? 'Connected' : 'Disconnected';
                ankiStatus.setAttribute('title', anki_connected ? 'Anki is connected.' : 'Anki is disconnected.');

            }).catch(error => {
                console.error('Error fetching GSM status:', error);
                // Optionally, set all statuses to error/red if communication with backend fails
                gsmStatusButton.classList.toggle('red', true);
                gsmStatusButton.classList.toggle('green', false);
                gsmStatusButton.querySelector('span:last-child').textContent = "Error";
                gsmStatusButton.setAttribute('title', 'Error communicating with GSM backend.');

                clipboardStatus.classList.toggle('red', true);
                clipboardStatus.classList.toggle('green', false);
                clipboardStatus.querySelector('span:last-child').textContent = "Error";

                obsStatus.classList.toggle('red', true);
                obsStatus.classList.toggle('green', false);
                obsStatus.querySelector('span:last-child').textContent = "Error";

                ankiStatus.classList.toggle('red', true);
                ankiStatus.classList.toggle('green', false);
                ankiStatus.querySelector('span:last-child').textContent = "Error";

                // Clear dynamic websocket buttons
                Object.keys(ws_showing).forEach(ws => {
                    websocketContainer.removeChild(ws_showing[ws]);
                    delete ws_showing[ws];
                });
            });
        }, 200);

        // function refreshScenesAndWindows(showLoading = true) {
        //     if (showLoading)
        //         document.getElementById('sceneSelect').innerHTML = '<option>Loading...</option>';
        //     getWindows(showLoading);
        // }

        refreshScenesAndWindows(true);

        // ====================================================================
        // Shared State: Hide "Run Overlay" button on non-Windows
        // ====================================================================

        async function applyOSSpecificUI() {
            // Get OS info from shared state (set by index.html)
            let systemInfo = await sharedState.getState('systemInfo');

            if (systemInfo) {
                let osInfo = systemInfo;
                console.log('Using OS info from shared state:', systemInfo);

                // Disable "Run Overlay" button and help icon on non-Windows
                const runOverlayBtn = document.getElementById('runOverlayBtn');
                const overlayHelpBtn = document.getElementById('open-overlay-wiki-btn');
                const refreshWindowsBtn = document.getElementById('refreshWindowsBtn');
                const createNewSceneBtn = document.getElementById('createNewSceneBtn');
                const createNewSceneGameBtn = document.getElementById('createNewSceneGameBtn');

                if (isWindows) {
                    if (runOverlayBtn) {
                        runOverlayBtn.disabled = false;
                        runOverlayBtn.style.opacity = '1';
                        runOverlayBtn.style.cursor = 'pointer';
                        runOverlayBtn.removeAttribute('title');
                    }
                    if (overlayHelpBtn) {
                        overlayHelpBtn.disabled = false;
                        overlayHelpBtn.style.opacity = '1';
                        overlayHelpBtn.style.cursor = 'pointer';
                        overlayHelpBtn.removeAttribute('title');
                    }
                    if (windowSelect) {
                        windowSelect.disabled = false;
                        windowSelect.style.cursor = '';
                        windowSelect.removeAttribute('title');
                    }
                    if (refreshWindowsBtn) {
                        refreshWindowsBtn.disabled = false;
                        refreshWindowsBtn.style.opacity = '';
                        refreshWindowsBtn.style.cursor = '';
                        refreshWindowsBtn.removeAttribute('title');
                    }
                    if (createNewSceneBtn) {
                        createNewSceneBtn.disabled = false;
                        createNewSceneBtn.style.opacity = '';
                        createNewSceneBtn.style.cursor = '';
                        createNewSceneBtn.removeAttribute('title');
                    }
                    if (createNewSceneGameBtn) {
                        createNewSceneGameBtn.disabled = false;
                        createNewSceneGameBtn.style.opacity = '';
                        createNewSceneGameBtn.style.cursor = '';
                        createNewSceneGameBtn.removeAttribute('title');
                    }
                } else {
                    if (runOverlayBtn) {
                        // runOverlayBtn.disabled = true;
                        runOverlayBtn.style.opacity = '0.5';
                        runOverlayBtn.title = 'Experimental suport on this OS';
                    }
                    // if (overlayHelpBtn) {
                    // overlayHelpBtn.disabled = true;
                    // overlayHelpBtn.style.opacity = '0.5';
                    // overlayHelpBtn.style.cursor = 'not-allowed';
                    // overlayHelpBtn.title = 'Not supported in this OS';
                    // }
                    windowSelect.innerHTML = '<option>Need to set scenes in OBS on this OS.</option>';
                    windowSelect.disabled = true;
                    windowSelect.style.cursor = 'not-allowed';
                    windowSelect.title = 'Not supported in this OS';
                    if (refreshWindowsBtn) {
                        refreshWindowsBtn.disabled = true;
                        refreshWindowsBtn.style.opacity = '0.5';
                        refreshWindowsBtn.style.cursor = 'not-allowed';
                        refreshWindowsBtn.title = 'Not supported in this OS';
                    }
                    if (createNewSceneBtn) {
                        createNewSceneBtn.disabled = true;
                        createNewSceneBtn.style.opacity = '0.5';
                        createNewSceneBtn.style.cursor = 'not-allowed';
                        createNewSceneBtn.title = 'Not supported in this OS';
                    }
                    if (createNewSceneGameBtn) {
                        createNewSceneGameBtn.disabled = true;
                        createNewSceneGameBtn.style.opacity = '0.5';
                        createNewSceneGameBtn.style.cursor = 'not-allowed';
                        createNewSceneGameBtn.title = 'Not supported in this OS';
                    }
                }
            }
        }

        // Apply on page load
        applyOSSpecificUI();

        // Listen for OS info changes (in case it gets set after this page loads)
        sharedState.onStateChanged('systemInfo', () => {
            applyOSSpecificUI();
        });
    </script>
</body>

</html>