<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="xterm.css">
    <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        body.index {
            margin: 0;
            padding: 0;
            height: 100vh;
            background: #1a1a1a;
            color: #ffffff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            /*overflow: hidden; !* Add this line *!*/
        }

        .tab-bar {
            background: #2a2a2a;
            padding: 10px;
            display: flex;
            gap: 5px;
            height: 50px;
            /* Example fixed height (adjust based on your padding) */
            /* If padding is included in height, use box-sizing: border-box; */
            box-sizing: border-box;
        }

        .tab-button {
            background: #3a3a3a;
            border: none;
            color: #ffffff;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .tab-button:hover {
            background: #4a4a4a;
        }

        .tab-button.active {
            background: #5a5a5a;
        }

        .tab-content {
            display: none;
            height: calc(100vh - 40px);
            /* Adjust 40px to be the exact height of your tab-bar */
            /*overflow: hidden; !* Add this to prevent internal scrollbars if content overflows *!*/
        }

        .tab-content.active {
            display: block;
            height: 100%;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        #terminal {
            width: 100%;
            height: 100%;
        }

        /* Python tab specific grid layout - max 2 columns */
        #python-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            max-width: 100%;
            gap: 15px;
        }

        /* Ensure Python grid never exceeds 2 columns */
        @media (min-width: 900px) {
            #python-grid-container {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
    <title></title>
</head>

<body class="index">
    <!-- Include shared module with ipcRenderer, clipboard, and sharedState -->
    <script src="shared.js"></script>
    
    <div id="main-tab-bar" class="tab-bar">
        <button class="tab-button active" data-tab="obs">Home</button>
        <button class="tab-button" data-tab="ocr">OCR</button>
        <button class="tab-button" data-tab="launcher">Game Launcher</button>
        <!--        <button class="tab-button" data-tab="steam">Steam</button>-->
        <!--        <button class="tab-button" data-tab="vn">VN</button>-->
        <!--        <button class="tab-button" data-tab="yuzu" id="yuzu-button" style="display: none;">Yuzu</button>-->
        <button class="tab-button" data-tab="settings">Settings</button>
        <button class="tab-button" data-tab="python">Python</button>
        <button class="tab-button" data-tab="stats">Stats</button>
        <button class="tab-button" data-tab="console">Console</button>
    </div>
    <div id="launcher" class="tab-content">
        <iframe src="launcher.html"></iframe>
    </div>
    <div id="obs" class="tab-content active">
        <iframe src="home.html"></iframe>
    </div>
    <div id="steam" class="tab-content">
        <iframe src="steam.html"></iframe>
    </div>
    <div id="vn" class="tab-content">
        <iframe src="VN.html"></iframe>
    </div>
    <div id="yuzu" class="tab-content">
        <iframe src="yuzu.html"></iframe>
    </div>
    <div id="settings" class="tab-content">
        <iframe src="settings.html"></iframe>
    </div>
    <div id="stats" class="tab-content">
        <iframe src=""></iframe>
    </div>
    <div id="python" class="tab-content">
        <div id="python-tab-container" class="tab-container">
            <h2>Python Management</h2>
            <strong>Everything on this tab has the potential to break GSM. Proceed with Caution.</strong>
            <div id="python-grid-container" class="grid-container">
                <!-- CUDA Installation Card -->
                <div class="card">
                    <h2 class="collapsible-header">CUDA Installation</h2>
                    <div class="collapsible-content" style="display: block;">
                        <div class="form-group">
                            <div class="input-group">
                                <label for="cuda-version-select">CUDA Version:
                                </label>
                                <select id="cuda-version-select">
                                    <option value="12.6">CUDA 12.6 (Stable)</option>
                                    <option value="12.8" selected>CUDA 12.8 (Recommended)</option>
                                    <option value="12.9">CUDA 12.9 (Latest)</option>
                                </select>
                                <button id="install-cuda-btn" class="secondary">Install CUDA</button>
                                <div class="tooltip">‚ùì
                                    <span class="tooltiptext">Install PyTorch with CUDA support for GPU acceleration.
                                        This enables much faster Whisper Processing, and is used for a few OCR options
                                        (none recommended).</span>
                                </div>
                            </div>
                            <div class="input-group">
                                <button id="cuda-guide-btn" class="secondary">üìñ CUDA Compatibility Guide</button>
                                <div class="tooltip">‚ùì
                                    <span class="tooltiptext">
                                        <strong>Choose your CUDA version:</strong><br>
                                        ‚Ä¢ <strong>CUDA 12.6:</strong> Most stable, works with older GPUs<br>
                                        ‚Ä¢ <strong>CUDA 12.8:</strong> Recommended for most users (RTX 30/40 series)<br>
                                        ‚Ä¢ <strong>CUDA 12.9:</strong> Latest version, best performance for newest
                                        GPUs<br><br>
                                        <strong>Note:</strong> Your GPU driver must support the CUDA version you choose.
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- GSM Management Card -->
                <div class="card">
                    <h2 class="collapsible-header">GSM Management</h2>
                    <div class="collapsible-content" style="display: block;">
                        <div class="form-group">
                            <!-- <div class="input-group">
                                <button id="repair-gsm-btn" class="danger">üîß Repair GSM</button>
                                <div class="tooltip">‚ùì
                                    <span class="tooltiptext">Complete reinstall of Python and GameSentenceMiner. This
                                        will remove all custom packages and restore to default state.</span>
                                </div>
                            </div> -->
                            <div class="input-group">
                                <button id="clean-cache-btn" class="secondary">üßπ Clean Python Cache</button>
                                <div class="tooltip">‚ùì
                                    <span class="tooltiptext">Clear pip cache and temporary files to fix installation
                                        issues</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Custom Package Installation Card -->
                <div class="card">
                    <h2 class="collapsible-header">Custom Package Installation</h2>
                    <div class="collapsible-content" style="display: block;">
                        <div class="form-group">
                            <div class="input-group">
                                <label for="custom-package-input" class="tooltip-indicator">Package Name:
                                    <span class="tooltiptext">Enter the name of the package you want to install (e.g.,
                                        numpy, requests, etc.) This may break things, and should only be used upon
                                        instruction.</span>
                                </label>
                                <input type="text" id="custom-package-input"
                                    placeholder="e.g., numpy, requests, etc." />
                                <button id="install-custom-package-btn" class="danger">Install Package</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Python Environment Info Card -->
                <div class="card">
                    <h2 class="collapsible-header">Python Environment Info</h2>
                    <div class="collapsible-content" style="display: block;">
                        <div class="form-group">
                            <div id="python-info-container">
                                <p id="python-version">Python Version: Loading...</p>
                                <p id="python-path">Python Path: Loading...</p>
                                <p id="pip-version">Pip Version: Loading...</p>
                            </div>
                            <div class="input-group">
                                <button id="refresh-python-info-btn" class="secondary">üîÑ Refresh Info</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Status Display -->
            <div class="card" id="python-status-card" style="display: none;">
                <div class="terminal-container" id="python-status">
                    <p id="python-status-text">Ready</p>
                </div>
            </div>
        </div>
    </div>
    <div id="ocr" class="tab-content">
        <div id="ocr-tab-container" class="tab-container">
            <div id="ocr-grid-container" class="grid-container">
                <div id='setup-card' class="card">
                    <h2 id="setup-header" class="collapsible-header">1. Installation <span class="arrow-icon">‚ñ≤</span>
                    </h2>
                    <div id="setup-collapsible-content" class="collapsible-content" style="display: block;">
                        <div class="form-group">
                            <button id="install-recommended-btn">Install OwOCR</button>
                            <div id="dependency-select-group" class="input-group">
                                <label for="dependency-select">Optional:</label>
                                <select id="dependency-select">
                                    <option value="pip install owocr[faster-png]">Faster PNG (Recommended if w11)
                                    </option>
                                    <option value="pip install owocr[winocr]">WindowsOCR</option>
                                    <option value="pip install owocr[mangaocr]">MangaOCR</option>
                                    <option value="pip install owocr[easyocr]">EasyOCR</option>
                                    <option value="pip install owocr[rapidocr]">RapidOCR</option>
                                    <option value="pip install owocr[gvision]">Google Vision (apikey required)</option>
                                    <option value="pip install owocr[azure]">Azure (apikey required)</option>
                                    <option value="pip install owocr[ocrspace]">OCRSpace (apikey required)</option>
                                    <option
                                        value="pip install torch torchvision torchaudio numpy==2.2.6 --index-url https://download.pytorch.org/whl/cu128">
                                        CUDA
                                    </option>
                                </select>
                                <button id="install-selected-dep" class="secondary">Install</button>
                                <div class="tooltip">‚ùì
                                    <span class="tooltiptext">Install the selected dependency. If unsure, choose a
                                        recommended option. Google Lens, and OneOCR are now installed with "Install
                                        OwOCR" button.</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id='config-card' class="card">
                    <h2 id="config-header" class="collapsible-header">2. Select Source <span class="arrow-icon">‚ñ≤</span>
                    </h2>
                    <div id="config-collapsible-content" class="collapsible-content" style="display: block;">
                        <div class="form-group">
                            <div id="scene-select-group" class="input-group">
                                <label for="sceneSelect" class="tooltip-indicator">Game (OBS Scene):
                                    <span class="tooltiptext tooltiptext-right">Select the OBS Scene to Capture for OCR.
                                        You can make a new Scene in the "Home" Tab</span>
                                </label>
                                <select id="sceneSelect"></select>
                                <button id="refreshScenesBtn" class="secondary">‚Üª</button>
                            </div>
                            <div id="window-select-group" class="input-group">
                                <label for="windowSelect" class="tooltip-indicator">Window:
                                    <span class="tooltiptext tooltiptext-right">Select the OBS window for the
                                        game</span>
                                </label>
                                <select id="windowSelect"></select>
                                <button id="refreshWindowsBtn" class="secondary">‚Üª</button>
                                <input type="checkbox" id="use-window-for-config">
                                <label for="use-window-for-config" class="tooltip-indicator tooltip-left"
                                    style="margin-left: 8px;">Bind Config to Window
                                    <span class="tooltiptext tooltiptext-left">If enabled, the Area Config will be saved
                                        under the name of the Window instead of the Game/OBS Scene</span>
                                </label>
                            </div>
                            <div id="screen-selector-group" class="input-group" style="justify-content: center;">
                                <button id="run-screen-selector">Run Area(s) Selector</button>
                                <button id="import-config-btn" class="secondary" title="Import OCR Config">üìã</button>
                                <button id="export-config-btn" class="secondary" title="Export OCR Config">üì§</button>
                                <button id="open-ocr-wiki-btn" class="secondary" title="Open OCR Area Selector Wiki">
                                    <span style="font-size: 14px;">‚ùì</span>
                                </button>
                                <script>
                                    document.getElementById('open-ocr-wiki-btn').addEventListener('click', () => {
                                        window.open('https://github.com/bpwhelan/GameSentenceMiner/wiki/OCR-%E2%80%90-Area-Selector', '_blank');
                                    });
                                </script>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card" id="ocr-settings-card">
                <h2 id="settings-header" class="collapsible-header"><span>3. OCR Settings</span> <span
                        class="arrow-icon">‚ñ≤</span></h2>
                <div id="ocr-settings-collapsible-content" class="collapsible-content" style="display: block;">
                    <div id="ocr-settings-grid-container" class="grid-container">
                        <div class="form-group">
                            <div id="ocr1-select-group" class="input-group">
                                <label for="ocr1-input" class="tooltip-indicator">
                                    Text Stability:
                                    <span class="tooltiptext tooltiptext-right">
                                        This will run at the set scan rate, and when the text stabilizes, it will
                                        trigger the main OCR.
                                        This should preferably be a fast engine. On Windows, OneOCR is recommended.
                                    </span>
                                </label>
                                <select id="ocr1-input">
                                    <option value="" disabled selected>Select Stability OCR</option>
                                    <!-- <option value="glens">Google Lens</option> -->
                                    <option value="bing">Bing</option>
                                    <option value="oneocr">OneOCR (Recommended)</option>
                                    <option value="meiki_text_detector">Meiki Text Detector (Experimental)</option>
                                    <!-- <option value="gemini">Gemini</option> -->
                                    <!-- <option value="qwenv2">Qwen2-VL</option> -->
                                    <option value="easyocr">EasyOCR</option>
                                    <option value="rapidocr">RapidOCR</option>
                                    <option value="mangaocr">MangaOCR</option>
                                    <option value="winrtocr">WindowsOCR</option>
                                    <!-- <option value="gvision">Google Vision</option> -->
                                    <!-- <option value="azure">Azure Image Analysis</option> -->
                                    <!-- <option value="ocrspace">OCRSpace</option> -->
                                    <option value="local_llm_ocr">Local LLM OCR</option>
                                    <option value="alivetext">Apple Live Text (Mac Only)</option>
                                </select>
                            </div>
                            <div id="ocr2-select-group" class="input-group">
                                <label for="ocr2-input" class="tooltip-indicator">Main OCR:
                                    <span class="tooltiptext tooltiptext-right">
                                        This engine will be used to send the result to clipboard/websocket. This should
                                        be an accurate engine. If Two Pass is enabled, it will be triggered after the
                                        text has stabilized on screen.
                                    </span>
                                </label>
                                <select id="ocr2-input">
                                    <option value="" disabled selected>Select Main OCR</option>
                                    <option value="glens">Google Lens (Recommended)</option>
                                    <option value="bing">Bing</option>
                                    <option value="oneocr">OneOCR</option>
                                    <option value="gemini">Gemini</option>
                                    <!-- <option value="qwenv2">Qwen2-VL</option> -->
                                    <option value="easyocr">EasyOCR</option>
                                    <option value="rapidocr">RapidOCR</option>
                                    <option value="mangaocr">MangaOCR</option>
                                    <option value="winrtocr">WindowsOCR</option>
                                    <option value="gvision">Google Vision</option>
                                    <option value="azure">Azure Image Analysis</option>
                                    <option value="ocrspace">OCRSpace</option>
                                    <option value="local_llm_ocr">Local LLM OCR</option>
                                    <option value="alivetext">Apple Live Text (Mac Only)</option>
                                </select>
                            </div>
                            <div id="language-select-group" class="input-group">
                                <label for="languageSelect">Language:</label>
                                <select id="languageSelect">
                                    <option value="ja">Japanese</option>
                                    <option value="zh">Chinese</option>
                                    <option value="ko">Korean</option>
                                    <option value="en">English</option>
                                    <option value="es">Spanish</option>
                                    <option value="fr">French</option>
                                    <option value="de">German</option>
                                    <option value="ru">Russian</option>
                                    <option value="ar">Arabic</option>
                                    <option value="hi">Hindi</option>
                                </select>
                            </div>
                            <div id="two-pass-ocr-group" class="input-group">
                                <label for="two-pass-ocr" class="tooltip-indicator tooltip-bottom tooltip-right">
                                    <span class="tooltiptext">
                                        OCR Option 1 runs at the set scan rate.
                                        If two pass is enabled, and the text does not change by the next scan,
                                        it will then do the second scan.
                                    </span>
                                    Enable Two Pass OCR:
                                </label>
                                <input type="checkbox" id="two-pass-ocr">
                            </div>
                            <div id="optimize-second-scan-group" class="input-group">
                                <label for="optimize-second-scan"
                                    class="tooltip-indicator tooltip-bottom tooltip-right">
                                    <span class="tooltiptext">Trim Image for second scan to improve performance. (OneOCR
                                        1st ONLY)<br> If your game's text is odd, and some text doesn't get captured,
                                        maybe try turning this off.</span>
                                    Optimize 2nd scan:
                                </label>
                                <input type="checkbox" id="optimize-second-scan" checked>
                            </div>
                            <div id="furigana-filter-group" class="input-group">
                                <label id="furigana-filter-label" for="furigana-filter-sensitivity"
                                    class="tooltip-indicator tooltip-bottom tooltip-right">
                                    Furigana Filter Sensitivity:
                                    <span class="tooltiptext">
                                        Filters characters smaller than the selected text size. Very experimental, if
                                        you
                                        notice real text being filtered out, either lower this or disable by setting to
                                        0.
                                        <br><br>
                                        <strong>Tip:</strong> Click <span style="color: blue;">Preview</span> to open a window that will help you select the best sensitivity for your current game.
                                    </span>
                                    <span id="furigana-filter-sensitivity-value">0</span>
                                    <input type="range" id="furigana-filter-sensitivity" min="0" max="100" value="0"
                                        step="1">
                                </label>
                                <span id="dynamic-size-display" style="cursor:pointer;">Preview</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <div id="ocr-scan-rate-group" class="input-group">
                                <label for="ocr-scan-rate" class="tooltip-indicator tooltip-bottom tooltip-right">Scan
                                    Rate (s):
                                    <span class="tooltiptext">
                                        <ul>
                                            <li>The OCR scan rate determines how frequently the OCR process scans the
                                                screen.</li>
                                            <li>Lower values increase responsiveness but may consume more resources.
                                            </li>
                                            <li>Higher values reduce resource usage but may delay updates.</li>
                                            <li>If your text doesn't appear instantly, lower values may result in
                                                partial text results.</li>
                                        </ul>
                                    </span>
                                </label>
                                <input type="number" id="ocr-scan-rate" value=".5" min="0" step=".1">
                            </div>
                            <div id="area-select-ocr-hotkey-group" class="input-group">
                                <label for="area-select-ocr-hotkey"
                                    class="tooltip-indicator tooltip-bottom tooltip-right">Area Select Hotkey:
                                    <span class="tooltiptext">On Press, will allow you to select an area to OCR one
                                        time. Useful for menus</span>
                                </label>
                                <input type="text" id="area-select-ocr-hotkey" value="Ctrl+Shift+O">
                            </div>
                            <div id="manual-ocr-hotkey-group" class="input-group">
                                <label for="manual-ocr-hotkey"
                                    class="tooltip-indicator tooltip-bottom tooltip-right">Manual/Menu OCR Hotkey:
                                    <span class="tooltiptext">
                                        Hotkey to manually OCR the selected area. This will run the OCR on the selected
                                        area and return the result. <strong>Note:</strong> This uses the OCR Option 2,
                                        and is also used to OCR Menus (Ctrl+Click in Area Selector)</span>
                                </label>
                                <input type="text" id="manual-ocr-hotkey" value="Ctrl+Shift+G">
                            </div>
                            <div id="require-open-window-group" class="input-group">
                                <label for="require-open-window"
                                    class="tooltip-indicator tooltip-bottom tooltip-right">Require Active Window:
                                    <span class="tooltiptext">If enabled, OCR will only run if the selected window is
                                        active AND focused. </span>
                                </label>
                                <input type="checkbox" id="require-open-window">
                            </div>
                            <div id="ocr-screenshots-group" class="input-group">
                                <label for="ocr-screenshots" class="tooltip-indicator tooltip-bottom tooltip-right">OCR
                                    Clipboard Screenshots:
                                    <span class="tooltiptext">If enabled, OCR will also process screenshots taken from
                                        the clipboard.</span>
                                </label>
                                <input type="checkbox" id="ocr-screenshots">
                            </div>
                            <div id="send-to-clipboard-group" class="input-group">
                                <label for="send-to-clipboard" class="tooltip-indicator tooltip-bottom tooltip-right">
                                    <span class="tooltiptext">OCR Sends text to Websocket by default, with this enabled,
                                        it will also copy to clipboard.</span>
                                    Send Text to Clipboard:
                                </label>
                                <input type="checkbox" id="send-to-clipboard">
                            </div>
                            <div id="keep-newline-group" class="input-group">
                                <label for="keep-newline" class="tooltip-indicator tooltip-bottom tooltip-right">
                                    <span class="tooltiptext">If enabled, OCR will attempt to keep newlines in the
                                        output text (for
                                        better readability) NOT GUARANTEED.</span>
                                    Maintain Line Breaks in Output:
                                </label>
                                <input type="checkbox" id="keep-newline">
                            </div>
                            <div id="select_areas_button_2" class="input-group" style="display:none;">
                                <button id="select-areas-button">Change Area Config</button>
                                <div class="tooltip">‚ùì
                                    <span class="tooltiptext">Select areas to OCR. This will open a window to select
                                        areas.</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <script>
                        document.getElementById('dynamic-size-display').addEventListener('click', async () => {
                            sensitivity = await ipcRenderer.invoke('run-furigana-window');
                            console.log('Furigana filter sensitivity set to:', sensitivity);
                            document.getElementById('furigana-filter-sensitivity').value = sensitivity;
                            document.getElementById('furigana-filter-sensitivity-value').innerText = sensitivity;
                        });
                    </script>
                </div>
            </div>

            <div class="card" id="ocr-log-card" style="display: none;">
                <div class="terminal-container" id="ocr-terminal"></div>
            </div>

            <div id="ocr-controls-card" class="card">
                <div id="start-ocr-controls" class="input-group" style="justify-content: center;">
                    <label class="tooltip">
                        <span id="config-tooltip">‚úó</span>
                        <span class="tooltiptext" id="ocr-config-summary"></span>
                    </label>
                    <button id="start-ocr">Start Auto OCR</button>
                    <button id="start-ocr-ss-only" class="secondary">Start Manual OCR</button>
                </div>
                <div id="stop-ocr-controls" class="input-group"
                    style="display: none; position: relative; justify-content: center; align-items: center; gap: 16px;">
                    <label id="ocr-status-label"
                        style="position: absolute; left: 0; text-align: left; font-size: 18px; padding-bottom: 15px"></label>
                    <div style="display: flex; gap: 16px;">
                        <button id="stop-ocr" class="danger">Stop OCR (Open Settings)</button>
                        <button id="pause-ocr" class="secondary">Pause OCR</button>
                    </div>
                </div>
            </div>

            <div id="debug-tools-card" class="card">
                <h2 id="debug-header" class="collapsible-header">
                    Extra & Debug Tools <span class="arrow-icon">‚ñº</span>
                </h2>
                <div id="extra-debug-content" class="collapsible-content" style="display: none;">
                    <div id="debug-grid-container" class="grid-container">
                        <div class="form-group">
                            <button id="open-ocr-page-btn" class="secondary">Open OCR Error Fixes Page</button>
                            <button id="open-config-json" class="secondary">Open Config File</button>
                            <button id="open-config-folder" class="secondary">Open OCR Config Folder</button>
                            <button id="open-temp-folder" class="secondary">Open Temp Folder (To see OCR'd Image
                                Samples)</button>
                        </div>
                        <div class="form-group">
                            <div id="dependency-removal-group" class="input-group">
                                <select id="dependency-select-removal">
                                    <option value="owocr">OWOCR Base</option>
                                    <option value="betterproto">Google Lens</option>
                                    <option value="oneocr">OneOCR</option>
                                    <option value="fpng-py">Faster PNG</option>
                                    <option value="transformers sentencepiece">Accurate Filtering</option>
                                    <option value="winocr">WindowsOCR</option>
                                    <option value="manga-ocr">MangaOCR</option>
                                    <option value="easyocr">EasyOCR</option>
                                    <option value="rapidocr onnxruntime rapidocr_onnxruntime">RapidOCR</option>
                                    <option value="google-cloud-vision">Google Vision</option>
                                    <option value="azure-ai-vision-imageanalysis">Azure</option>
                                    <option value="ocrspace">OCRSpace</option>
                                </select>
                                <button id="uninstall-selected-dep" class="danger">Uninstall</button>
                            </div>
                            <div id="use-obs-as-source-group" class="input-group">
                                <label for="use-obs-as-source" class="tooltip-indicator tooltip-bottom tooltip-right">
                                    Use OBS as Source:
                                    <span class="tooltiptext">Disable this to use native python functions to capture
                                        the screen. This may be more performant, but also much less reliable.
                                        <br><br>
                                        If you have issues with OBS capturing, try disabling this.
                                        <br><br>
                                        LINUX COMPAT TOO</span>
                                </label>
                                <input type="checkbox" id="use-obs-as-source">
                            </div>
                            <div id="uninstall-status"></div>
                        </div>
                    </div>
                </div>
            </div>

            <script>
                let current_scene_config = null;
                let ocr_settings = null;
                let windows = [];
                let scenes = [];

                let importConfigBtn = document.getElementById('import-config-btn');
                let exportConfigBtn = document.getElementById('export-config-btn');

                importConfigBtn.addEventListener('click', async () => {
                    const result = await ipcRenderer.invoke('ocr.import-ocr-config');
                    if (result.success) {
                        alert('Import successful!');
                        loadCurrentConfig();
                    } else {
                        alert('Import failed: ' + result.message);
                    }
                });

                exportConfigBtn.addEventListener('click', async () => {
                    const result = await ipcRenderer.invoke('ocr.export-ocr-config');
                    if (result.success) {
                        alert('Exported Config to Clipboard!');
                    } else {
                        alert('Export failed: ' + result.message);
                    }
                });

                const ocrTerm = new Terminal({
                    convertEol: true,
                    fontFamily: '"Noto Sans Mono", "IPA Gothic", "Courier New", monospace',
                    fontSize: 14,
                    disableStdin: false,
                    theme: {
                        foreground: "#EEEEEE",
                        background: "#2c2c2c",
                        cursor: "#CFF5DB"
                    },
                    allowTransparency: true,
                });


                const ocrFitAddon = new FitAddon.FitAddon();
                ocrTerm.loadAddon(ocrFitAddon);
                ocrTerm.open(document.getElementById('ocr-terminal'));
                document.getElementById('ocr-terminal').style.height = '300px';
                ocrFitAddon.fit();

                ocrTerm.onData(e => {
                    ipcRenderer.send('ocr.stdin', e);
                });

                ocrTerm.attachCustomKeyEventHandler((arg) => {
                    if (arg.ctrlKey && arg.code === "KeyC" && arg.type === "keydown") {
                        const selection = ocrTerm.getSelection();
                        if (selection) {
                            clipboard.writeText(selection);
                            return false;
                        }
                    }
                    return true;
                });

                document.getElementById("ocr-terminal").addEventListener('contextmenu', () => {
                    if (ocrTerm.hasSelection()) {
                        document.execCommand('copy');
                        ocrTerm.select(0, 0, 0);
                    }
                });

                let paused = false;
                let isScanning = false;
                let isSleeping = false;
                // Use periods for animation, but style them larger in the status label
                const dotsAnimation = ['.', '..', '...', '....'];
                const scanningAnimation = ['.', '..', '...', '....'];
                let animationFrame = 0;
                let sleepingAnimationFrame = 1;

                function stopScanningAnimation() {
                    // if (isScanning) {
                    //     clearInterval(scanningInterval);
                    try {
                        ocrTerm.write('\r\x1b[2K'); // Go to beginning of line and clear it
                    } catch (e) {
                        // Terminal might be closed, ignore error
                    }
                    isScanning = false;
                    isSleeping = false;
                    animationFrame = 0;
                    sleepingAnimationFrame = 1;
                    // }
                }

                previous_message = "";

                const engineColors = {
                    "OneOCR": { ansi: "\x1b[36m", html: "color: #00FFFF;" },
                    "Google Lens": { ansi: "\x1b[92m", html: "color: #00FF00;" },
                    "Gemini": { ansi: "\x1b[95m", html: "color: #FF77FF;" },
                    "Bing": { ansi: "\x1b[34m", html: "color: #0000FF;" },
                    "EasyOCR": { ansi: "\x1b[33m", html: "color: #FFFF00;" },
                    "RapidOCR": { ansi: "\x1b[35m", html: "color: #FF00FF;" },
                    "Manga OCR": { ansi: "\x1b[95m", html: "color: #FF77FF;" },
                    "WindowsOCR": { ansi: "\x1b[36m", html: "color: #00FFFF;" },
                    "WinRT OCR": { ansi: "\x1b[36m", html: "color: #00FFFF;" },
                    "Google Vision": { ansi: "\x1b[92m", html: "color: #00FF00;" },
                    "Azure Image Analysis": { ansi: "\x1b[96m", html: "color: #00FFFF;" },
                    "OCRSpace": { ansi: "\x1b[93m", html: "color: #FFFF00;" },
                    "Qwen2-VL": { ansi: "\x1b[90m", html: "color: #808080;" },
                    "Local LLM OCR": { ansi: "\x1b[95m", html: "color: #D6A4FF;" },
                    "Meiki": { ansi: "\x1b[91m", html: "color: crimson;" },
                };

                function getEngineColor(engine, ansi = true) {
                    return engineColors[engine]?.[ansi ? "ansi" : "html"] || "";
                }

                function getEngineFormatString(engine_name, textToFormat, ansi = true) {
                    if (!engine_name) return textToFormat;
                    const color = getEngineColor(engine_name, ansi);
                    if (color) {
                        return ansi ? `${color}${textToFormat}\x1b[0m` : `<span style="${color}">${textToFormat}</span>`;
                    }
                    // return color ? ansi ? `${color}[${engine_name}] \x1b[0m${textToFormat}` : `<span style="${color}">${engine_name}</span> ${textToFormat}` : textToFormat;
                }

                function replaceEngineNameWithColor(text, ansi = true, endColor = true) {
                    for (const engine in engineColors) {
                        const color = getEngineColor(engine, ansi);
                        const regex = new RegExp(`\\b${engine}\\b`, 'g');
                        const end = endColor ? (ansi ? `\x1b[0m` : `</span>`) : '';
                        text = text.replace(regex, ansi ? `${color}${engine}${end}` : `<span style="${color}">${engine}${end}</span>`);
                    }
                    return text;
                }

                ipcRenderer.on('ocr-log', (event, data) => {
                    const trimmedData = data.trim();
                    const trimmedDataLower = trimmedData.toLowerCase();
                    const engine_name = trimmedData.includes("using") ? trimmedData.split("using")[1].split(":")[0].trim() : "";
                    let engine_pretty_ansi = getEngineFormatString(engine_name, engine_name, true);
                    let engine_pretty_html = getEngineFormatString(engine_name, engine_name, false);
                    if (trimmedData.endsWith("sleeping.")) {
                        if (!isSleeping) {
                            // ocrTerm.write(trimmedData);
                            isSleeping = true;
                        } else if (isSleeping || ocr_settings?.scanRate > 0.5) {
                            // ocrTerm.write('\r\x1b[2K');
                            // ocrTerm.write('\r' + trimmedData.trim() + dotsAnimation[sleepingAnimationFrame]);
                            document.getElementById('ocr-status-label').innerHTML = "<b>Status</b>: Sleeping - Image empty or unchanged" + '<span style="font-size: 2.0em;">' + dotsAnimation[sleepingAnimationFrame] + '</span>';
                            sleepingAnimationFrame = (sleepingAnimationFrame + 1) % dotsAnimation.length;
                        }
                        return;
                    }

                    if (trimmedData.includes("COMMAND_FINISHED")) {
                        closeOCRConsole();
                        return;
                    }
                    if (trimmedData.endsWith(engine_name + ":") && !paused) {
                        // Start scanning animation
                        document.getElementById('ocr-status-label').innerHTML = "<b>Status</b>: Scanning using " + engine_pretty_html + '<span style="font-size: 2.0em;">' + scanningAnimation[animationFrame] + '</span>';
                        animationFrame = (animationFrame + 1) % scanningAnimation.length;
                        //if (!isScanning) {
                        //   isScanning = true;
                        //} else if (isScanning || ocr_settings?.scanRate > 0.5) {
                        //    ocrTerm.write('\r\x1b[2K');
                        //    ocrTerm.write('\r' + trimmedData.split(" | ")[0] + ' | ' + "Scanning for text using " + engine_pretty + scanningAnimation[animationFrame]);
                        //    animationFrame = (animationFrame + 1) % scanningAnimation.length;
                        //}

                        // if (!isScanning) {
                        //     isScanning = true;
                        //     scanningInterval = setInterval(() => {
                        //         try {
                        //             ocrTerm.write('\r' + scanningAnimation[animationFrame]);
                        //             animationFrame = (animationFrame + 1) % scanningAnimation.length;
                        //         } catch (e) {
                        //             stopScanningAnimation();
                        //         }
                        //     }, 500);
                        // }
                    } else if (trimmedData.includes("Seems like Text we already sent")) {
                        // Add a "Duplicate" flag at the end of the previous line"
                        ocrTerm.write('\r\x1b[2K'); // Clear the line
                        ocrTerm.write(`\x1b[33m${previous_message} (Duplicate)\x1b[0m\n`);
                    } else if (trimmedDataLower.includes("boxes recognized with meiki")) {
                        // ocrTerm.writeln(getEngineFormatString(engine_name, replaceEngineNameWithColor(trimmedData, true), true));
                        document.getElementById('ocr-status-label').innerHTML = "<b>Status</b>: Scanning using " + engine_pretty_html + '<span style="font-size: 2.0em;">' + scanningAnimation[animationFrame] + '</span>';
                        animationFrame = (animationFrame + 1) % scanningAnimation.length;
                        previous_message = trimmedData;
                    } else if (trimmedData) {
                        stopScanningAnimation();
                        ocrTerm.writeln(getEngineFormatString(engine_name, replaceEngineNameWithColor(trimmedData, true, !trimmedData.includes("Text recognized")), true));
                        previous_message = trimmedData;
                    }
                });

                ipcRenderer.on('ocr-started', () => {
                    openOCRConsole("Stop OCR (Open Settings)", {
                        hideSetupCard: true,
                        hideConfigCard: true,
                        showLogCard: true,
                        hideStartControls: true,
                        showStopControls: true,
                        hideManualHotkey: true,
                        hideAreaHotkey: true,
                        hideScreenshotsGroup: true,
                        showSelectAreasButton: true,
                        updateSettingsHeader: false,
                        fitIntervalMs: 500,
                    });
                });

                ipcRenderer.on('ocr-stopped', () => {
                    // closeOCRConsole();
                });

                processes_using_console = 0;

                function openOCRConsole(closeConsoleButtonText, options = {}) {
                    if (!closeConsoleButtonText) {
                        closeConsoleButtonText = "Stop OCR (Open Settings)";
                    }
                    processes_using_console++;
                    // Default options
                    const {
                        hideSetupCard = true,
                        hideConfigCard = true,
                        hideSettingsCard = false,
                        showLogCard = true,
                        hideStartControls = true,
                        showStopControls = true,
                        hideManualHotkey = true,
                        hideAreaHotkey = true,
                        hideScreenshotsGroup = true,
                        showSelectAreasButton = true,
                        updateSettingsHeader = true,
                        fitIntervalMs = 500,
                    } = options;

                    if (hideSetupCard)
                        document.getElementById('setup-card').style.display = 'none';
                    if (hideConfigCard)
                        document.getElementById('config-card').style.display = 'none';
                    if (hideSettingsCard)
                        document.getElementById('ocr-settings-card').style.display = 'none';
                    if (showLogCard)
                        document.getElementById('ocr-log-card').style.display = 'block';
                    if (hideStartControls)
                        document.getElementById('start-ocr-controls').style.display = 'none';
                    if (showStopControls)
                        document.getElementById('stop-ocr-controls').style.display = 'flex';
                    document.getElementById('stop-ocr').innerText = closeConsoleButtonText;
                    if (hideManualHotkey)
                        document.getElementById('manual-ocr-hotkey-group').style.display = 'none';
                    if (hideAreaHotkey)
                        document.getElementById('area-select-ocr-hotkey-group').style.display = 'none';
                    if (updateSettingsHeader)
                        document.getElementById('settings-header').firstChild.innerText = 'OCR Settings (Some Options Hidden)';
                    if (hideScreenshotsGroup)
                        document.getElementById('ocr-screenshots-group').style.display = 'none';
                    if (showSelectAreasButton)
                        document.getElementById('select_areas_button_2').style.display = 'block';

                    setInterval(() => ocrFitAddon.fit(), fitIntervalMs);
                }

                function closeOCRConsole() {
                    processes_using_console--;
                    if (processes_using_console > 0) return;
                    stopScanningAnimation();
                    ['settings-header', 'setup-header', 'config-header'].forEach(id => {
                        toggleCollapsibleSectionById(id, true)
                    });
                    document.getElementById('setup-card').style.display = 'block';
                    document.getElementById('config-card').style.display = 'block';
                    document.getElementById('ocr-settings-card').style.display = 'block';

                    document.getElementById('ocr-log-card').style.display = 'none';
                    document.getElementById('start-ocr-controls').style.display = 'flex';
                    document.getElementById('stop-ocr-controls').style.display = 'none';
                    document.getElementById('stop-ocr').innerText = "Stop OCR (Open Settings)";
                    // document.getElementById('use-obs-as-source-group').style.display = 'flex';
                    //Show Hotkey config
                    document.getElementById('manual-ocr-hotkey-group').style.display = 'flex';
                    document.getElementById('area-select-ocr-hotkey-group').style.display = 'flex';
                    //Show two pass
                    document.getElementById('two-pass-ocr-group').style.display = 'flex';
                    document.getElementById('settings-header').firstChild.innerText = '3. OCR Settings';
                    // Show clipboard screenshot option
                    document.getElementById('ocr-screenshots-group').style.display = 'flex';
                    document.getElementById('ocr-status-label').innerText = "";
                    document.getElementById('select_areas_button_2').style.display = 'none';
                    refreshActiveOCRWindow();
                }

                const installRecommendedBtn = document.getElementById('install-recommended-btn');
                const openOcrPageBtn = document.getElementById('open-ocr-page-btn');
                const windowSelect = document.getElementById("windowSelect");
                const manualOcrHotkeyInput = document.getElementById('manual-ocr-hotkey');
                const furiganaFilterSlider = document.getElementById('furigana-filter-sensitivity');
                const furiganaFilterValue = document.getElementById('furigana-filter-sensitivity-value');
                const dynamicSizeDisplay = document.getElementById('dynamic-size-display');
                const areaSelectOCRHotkeyInput = document.getElementById('area-select-ocr-hotkey');
                const sceneSelect = document.getElementById('sceneSelect');
                const sendToClipboardCheckbox = document.getElementById('send-to-clipboard');
                const useWindowForConfigCheckbox = document.getElementById('use-window-for-config');

                const setHotkey = (event, inputElement) => {
                    event.preventDefault();
                    const keys = [];
                    if (event.ctrlKey) keys.push('Ctrl');
                    if (event.shiftKey) keys.push('Shift');
                    if (event.altKey) keys.push('Alt');
                    if (event.key && !['Control', 'Shift', 'Alt'].includes(event.key)) keys.push(event.key.toUpperCase());
                    inputElement.value = keys.join('+');
                    saveOCRConfig();
                };

                manualOcrHotkeyInput.addEventListener('keydown', (e) => setHotkey(e, manualOcrHotkeyInput));
                areaSelectOCRHotkeyInput.addEventListener('keydown', (e) => setHotkey(e, areaSelectOCRHotkeyInput));

                furiganaFilterSlider.addEventListener('input', () => {
                    const sensitivity = furiganaFilterSlider.value;
                    furiganaFilterValue.textContent = sensitivity;
                    // dynamicSizeDisplay.style.fontSize = sensitivity + 'px';
                    ipcRenderer.send('update-furigana-character', "Èæç", sensitivity);
                    saveOCRConfig();
                });

                installRecommendedBtn.addEventListener('click', () => {
                    openOCRConsole("Close Console", {
                        hideSetupCard: false,
                        hideConfigCard: true,
                        hideSettingsCard: true,
                        showLogCard: true,
                        hideStartControls: true,
                        showStopControls: true,
                        hideManualHotkey: false,
                        hideAreaHotkey: false,
                        hideScreenshotsGroup: false,
                        showSelectAreasButton: false,
                        updateSettingsHeader: false,
                        fitIntervalMs: 500,
                    });
                    ipcRenderer.send('ocr.install-recommended-deps');
                });

                openOcrPageBtn.addEventListener('click', () => {
                    window.location.href = 'ocr_replacements.html';
                });

                sendToClipboardCheckbox.addEventListener('change', saveOCRConfig)
                useWindowForConfigCheckbox.addEventListener('change', () => {
                    saveOCRConfig();
                    refreshActiveOCRWindow();
                });

                document.getElementById('refreshWindowsBtn').addEventListener('click', getWindows);
                document.getElementById('install-selected-dep').addEventListener('click', () => {
                    const selectedDep = document.getElementById('dependency-select').value;
                    openOCRConsole("Close Console", {
                        hideSetupCard: false,
                        hideConfigCard: true,
                        hideSettingsCard: true,
                        showLogCard: true,
                        hideStartControls: true,
                        showStopControls: true,
                        hideManualHotkey: false,
                        hideAreaHotkey: false,
                        hideScreenshotsGroup: false,
                        showSelectAreasButton: false,
                        updateSettingsHeader: false,
                        fitIntervalMs: 500,
                    });
                    ipcRenderer.send('ocr.install-selected-dep', selectedDep);
                });
                document.getElementById('uninstall-selected-dep').addEventListener('click', () => {
                    const selectedDep = document.getElementById('dependency-select-removal').value;
                    ipcRenderer.send('ocr.uninstall-selected-dep', selectedDep);
                });

                ['run-screen-selector', 'select_areas_button_2'].forEach(id => {
                    document.getElementById(id).addEventListener('click', async () => {
                        if (id === "run-screen-selector")
                            hideSettingsCard = true;
                        else
                            hideSettingsCard = false;
                        openOCRConsole("Close Console", {
                            hideSetupCard: true,
                            hideConfigCard: false,
                            hideSettingsCard: hideSettingsCard,
                            showLogCard: true,
                            hideStartControls: true,
                            showStopControls: true,
                            hideManualHotkey: false,
                            hideAreaHotkey: false,
                            hideScreenshotsGroup: false,
                            showSelectAreasButton: false,
                            updateSettingsHeader: false,
                            fitIntervalMs: 500,
                        });
                        const windowName = document.getElementById('windowSelect').value.trim();
                        await ipcRenderer.send('ocr.run-screen-selector', windowName);
                    });
                });

                document.getElementById('open-config-json').addEventListener('click', () => ipcRenderer.invoke('ocr.open-config-json'));
                document.getElementById('open-config-folder').addEventListener('click', () => ipcRenderer.invoke('ocr.open-config-folder'));
                document.getElementById('start-ocr').addEventListener('click', () => {
                    ocrTerm.clear();
                    stopScanningAnimation();
                    saveOCRConfig();
                    ipcRenderer.send('ocr.start-ocr');
                });
                document.getElementById('start-ocr-ss-only').addEventListener('click', () => {
                    ocrTerm.clear();
                    stopScanningAnimation();
                    saveOCRConfig();
                    ipcRenderer.send('ocr.start-ocr-ss-only');
                });
                document.getElementById('stop-ocr').addEventListener('click', () => {
                    ipcRenderer.send('ocr.kill-ocr');
                    closeOCRConsole();
                });
                document.getElementById('pause-ocr').addEventListener('click', () => {
                    if (document.getElementById('pause-ocr').innerText === 'Resume OCR') {
                        paused = false;
                        document.getElementById('pause-ocr').innerText = 'Pause OCR';
                    }
                    else {
                        paused = true;
                        document.getElementById('pause-ocr').innerText = 'Resume OCR';
                        stopScanningAnimation();
                    }
                    ipcRenderer.send('ocr.stdin', 'p');
                });
                document.getElementById('sceneSelect').addEventListener('change', (event) => {
                    ipcRenderer.invoke('obs.switchScene.id', event.target.value);
                    setTimeout(() => refreshActiveOCRWindow(), 500);
                });

                windowSelect.addEventListener('change', (event) => {
                    saveOCRConfig();
                    if (useWindowForConfigCheckbox.checked)
                        refreshActiveOCRWindow();
                });
                document.getElementById('refreshScenesBtn').addEventListener('click', refreshScenesAndWindows);

                ['two-pass-ocr', 'windowSelect', 'ocr1-input', 'ocr2-input', 'ocr-scan-rate', 'require-open-window', 'languageSelect', 'ocr-screenshots', 'optimize-second-scan'].forEach(id => {
                    switch (id) {
                        case 'two-pass-ocr':
                            document.getElementById('two-pass-ocr').addEventListener('change', (event) => {
                                if (event.target.checked) {
                                    document.getElementById('ocr1-select-group').style.display = 'flex';
                                    document.getElementById('optimize-second-scan-group').style.display = 'flex';
                                } else {
                                    document.getElementById('ocr1-select-group').style.display = 'none';
                                    document.getElementById('optimize-second-scan-group').style.display = 'none';
                                }
                            });
                    }
                    document.getElementById(id).addEventListener('change', saveOCRConfig);
                });

                document.getElementById('use-obs-as-source').addEventListener('change', (event) => {
                    ocr_settings.useObsAsOCRSource = event.target.checked;
                    if (!ocr_settings.useObsAsOCRSource) {
                        document.getElementById('window-select-group').style.display = 'flex';
                        document.getElementById('require-open-window-group').style.display = 'flex';
                    } else {
                        document.getElementById('window-select-group').style.display = 'none';
                        document.getElementById('require-open-window-group').style.display = 'none';
                    }
                    saveOCRConfig();
                });

                document.getElementById('keep-newline').addEventListener('change', saveOCRConfig);

                function refreshActiveOCRWindow() {
                    ipcRenderer.invoke('ocr.getActiveOCRConfig').then(config => {
                        if (!config) {
                            document.getElementById('config-tooltip').innerText = '‚úó';
                            document.getElementById('ocr-config-summary').textContent = 'No active OCR configuration found.';
                            return;
                        }
                        const furiganaSensitivity = config.furiganaFilterSensitivity;
                        document.getElementById('furigana-filter-sensitivity').value = Number(furiganaSensitivity) || 0;
                        document.getElementById('furigana-filter-sensitivity-value').textContent = furiganaSensitivity || 0;
                        const windowName = config.window;
                        document.getElementById('config-tooltip').innerText = '‚úì';
                        document.getElementById('ocr-config-summary').innerHTML = `Selected Config: ${config.scene || 'None'}<br> Rectangles: ${config.rectangles?.length || 0}`;
                        if (windowName && !windows.some(window => window === windowName)) {
                            const option = document.createElement('option');
                            option.value = windowName;
                            option.textContent = windowName;
                            windowSelect.appendChild(option);
                        }
                        if (windowName) windowSelect.value = windowName;
                    });
                }

                function getOBSWindows() {
                    ipcRenderer.invoke('obs.getSceneActiveWindow').then(activeWindow => {
                        const matchingWindow = windows.find(window => window === activeWindow);
                        if (matchingWindow) windowSelect.value = matchingWindow;
                    });
                }

                function getWindows(showLoading = true) {
                    // Remember the previously selected window
                    const previousSelection = windowSelect.value;

                    if (showLoading)
                        windowSelect.innerHTML = '<option>Loading...</option>';
                    ipcRenderer.invoke('ocr.getWindows').then(windowsRes => {
                        windows = windowsRes;
                        windowSelect.innerHTML = '';
                        windows.forEach(window => {
                            const option = document.createElement('option');
                            option.value = window;
                            option.textContent = window;
                            windowSelect.appendChild(option);
                        });

                        // Restore previous selection if it still exists in the list
                        if (previousSelection && windows.includes(previousSelection)) {
                            windowSelect.value = previousSelection;
                        }

                        getOBSWindows();
                        refreshActiveOCRWindow();
                    });
                }

                function refreshScenesAndWindows(showLoading = true) {
                    // Remember the previously selected scene
                    const previousSceneSelection = sceneSelect.value;

                    if (showLoading)
                        sceneSelect.innerHTML = '<option>Loading...</option>';
                    ipcRenderer.invoke('obs.getScenes').then(obsScenes => {
                        scenes = obsScenes;
                        sceneSelect.innerHTML = '';
                        scenes.forEach(scene => {
                            const option = document.createElement('option');
                            option.value = scene.id;
                            option.textContent = scene.name;
                            sceneSelect.appendChild(option);
                        });
                        ipcRenderer.invoke('obs.getActiveScene').then(activeScene => {
                            if (activeScene) {
                                if (scenes.some(s => s.id === activeScene.id)) {
                                    sceneSelect.value = activeScene.id;
                                }
                            }
                        });
                        getWindows(showLoading);
                    });
                }

                async function saveOCRConfig() {
                    ocr_settings = {
                        window_name: document.getElementById('windowSelect').value.trim(),
                        ocr1: document.getElementById('ocr1-input').value,
                        ocr2: document.getElementById('ocr2-input').value,
                        twoPassOCR: document.getElementById('two-pass-ocr').checked,
                        optimize_second_scan: document.getElementById('optimize-second-scan').checked,
                        requiresOpenWindow: document.getElementById('require-open-window').checked,
                        scanRate: document.getElementById('ocr-scan-rate').value,
                        language: document.getElementById('languageSelect').value,
                        ocr_screenshots: document.getElementById('ocr-screenshots').checked,
                        furigana_filter_sensitivity: document.getElementById('furigana-filter-sensitivity').value,
                        manualOcrHotkey: manualOcrHotkeyInput.value,
                        areaSelectOcrHotkey: areaSelectOCRHotkeyInput.value,
                        sendToClipboard: sendToClipboardCheckbox.checked,
                        useWindowForConfig: useWindowForConfigCheckbox.checked,
                        lastWindowSelected: windowSelect.value.trim(),
                        keep_newline: document.getElementById('keep-newline').checked,
                        useObsAsOCRSource: document.getElementById('use-obs-as-source').checked,
                    };
                    await ipcRenderer.send('ocr.save-ocr-config', ocr_settings);
                }

                async function initialize() {
                    ocr_settings = await ipcRenderer.invoke('ocr.get-ocr-config');
                    console.log('Loaded OCR Settings:', ocr_settings);
                    if (ocr_settings) {
                        document.getElementById('ocr1-input').value = ocr_settings.ocr1 || '';
                        document.getElementById('ocr2-input').value = ocr_settings.ocr2 || '';
                        document.getElementById('two-pass-ocr').checked = ocr_settings.twoPassOCR;
                        document.getElementById('optimize-second-scan').checked = ocr_settings.optimize_second_scan === undefined ? true : ocr_settings.optimize_second_scan;
                        document.getElementById('require-open-window').checked = ocr_settings.requiresOpenWindow;
                        document.getElementById('ocr-scan-rate').value = ocr_settings.scanRate || 0.5;
                        document.getElementById('languageSelect').value = ocr_settings.language || 'ja';
                        document.getElementById('ocr-screenshots').checked = ocr_settings.ocr_screenshots;
                        document.getElementById('keep-newline').checked = ocr_settings.keep_newline;
                        sendToClipboardCheckbox.checked = ocr_settings.sendToClipboard;
                        useWindowForConfigCheckbox.checked = ocr_settings.useWindowForConfig;
                        let useObsAsOCRSource = ocr_settings.useObsAsOCRSource !== false;
                        document.getElementById('use-obs-as-source').checked = useObsAsOCRSource;
                        if (!useObsAsOCRSource) {
                            document.getElementById('window-select-group').style.display = 'flex';
                            document.getElementById('require-open-window-group').style.display = 'flex';
                        } else {
                            document.getElementById('window-select-group').style.display = 'none';
                            document.getElementById('require-open-window-group').style.display = 'none';
                        }

                        if (ocr_settings.twoPassOCR) {
                            document.getElementById('ocr1-select-group').style.display = 'flex';
                            document.getElementById('optimize-second-scan-group').style.display = 'flex';
                        } else {
                            document.getElementById('ocr1-select-group').style.display = 'none';
                            document.getElementById('optimize-second-scan-group').style.display = 'none';
                        }
                        windowSelect.value = ocr_settings.lastWindowSelected;

                        const sensitivity = ocr_settings.furigana_filter_sensitivity || 0;
                        furiganaFilterSlider.value = sensitivity;
                        furiganaFilterValue.textContent = sensitivity;
                        // dynamicSizeDisplay.style.fontSize = sensitivity + 'px';

                        manualOcrHotkeyInput.value = ocr_settings.manualOcrHotkey || 'Ctrl+Shift+G';
                        areaSelectOCRHotkeyInput.value = ocr_settings.areaSelectOcrHotkey || 'Ctrl+Shift+O';
                    }
                    refreshScenesAndWindows();
                    setInterval(() => refreshScenesAndWindows(false), 5000);
                }

                // document.getElementById('furigana-filter-label').addEventListener('click', () => {
                //     ipcRenderer.send('run-furigana-window', {
                //         char: "Èæç",
                //         fontSize: furiganaFilterSlider.value,
                //     });
                // });

                document.addEventListener('DOMContentLoaded', () => {
                    initialize();
                    setupCollapsibleSections();
                });

                /**
                 * Sets up click listeners for all collapsible sections.
                 */
                function setupCollapsibleSections() {
                    document.querySelectorAll('.collapsible-header').forEach(header => {
                        header.addEventListener('click', () => {
                            toggleCollapsibleSection(header);
                        });
                    });
                }

                /**
                 * Toggles a collapsible section by header element.
                 * Can be called externally: toggleCollapsibleSection(headerElement, forceState)
                 * @param {HTMLElement} header - The header element to toggle.
                 * @param {boolean} [forceState] - Optional. If true, expand; if false, collapse; if undefined, toggle.
                 */
                function toggleCollapsibleSection(header, forceState) {
                    const content = header.nextElementSibling;
                    const arrow = header.querySelector('.arrow-icon');
                    const isHidden = content.style.display === 'none';
                    const shouldShow = forceState === undefined ? isHidden : forceState;

                    content.style.display = shouldShow ? 'block' : 'none';
                    if (arrow) {
                        arrow.textContent = shouldShow ? '‚ñ≤' : '‚ñº';
                    }
                    if (content.id === 'ocr-terminal') {
                        ocrFitAddon.fit();
                    }
                }

                function toggleCollapsibleSectionById(id, forceState) {
                    const header = document.getElementById(id);
                    if (header && header.classList.contains('collapsible-header')) {
                        toggleCollapsibleSection(header, forceState);
                    }
                }
            </script>
        </div>
    </div>
    <div id="console" class="tab-content">
        <div id="terminal"></div>
        <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
        <script>
            const term = new Terminal({
                fontFamily: '"Noto Sans Mono", "IPA Gothic", "Courier New", monospace', // Japanese-supporting fonts
                fontSize: 14,
                cursorBlink: false,
                allowProposedApi: true,
                theme: {
                    foreground: "#EEEEEE",
                    background: "#1a1a1a",
                    cursor: "#CFF5DB"
                },
            });
            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('terminal'));
            fitAddon.fit();

            // Helper function to switch to console tab
            function switchToConsoleTab() {
                // Remove active from all tabs
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

                // Activate console tab
                document.querySelector('[data-tab="console"]').classList.add('active');
                document.getElementById('console').classList.add('active');

                // Fit terminal
                setTimeout(() => {
                    fitAddon.fit();
                }, 100);
            }

            window.addEventListener('resize', () => fitAddon.fit());

            ipcRenderer.on('terminal-output', (event, data) => {
                if (data.includes("Python not found")) {
                    switchToConsoleTab();
                }
                if (data.includes("ERROR: INFO:") || data.includes("DEBUG:") || data.includes("[OCR")) {
                    return; // THIS IS DEBUG THAT SOMEHOW GETS THROUGH TO STDOUT
                }
                if (data.includes("Transcribe:")) {
                    const transcription = data.split("Transcribe:")[1].trim();
                    term.write(`\x1b[32mTranscription: ${transcription}\x1b[0m`); // Green text for transcriptions
                    return
                }
                // if (data.includes("GameSentenceMiner - "))
                //     data = data.split("GameSentenceMiner - ")[1];
                if (data.includes("- ERROR -")) {
                    term.write(`\x1b[91m${data}\x1b[0m`); // Light red text for errors, no background
                } else if (data.includes("- WARNING -")) {
                    term.write(`\x1b[33mWARNING: ${data}\x1b[0m`); // Yellow text for warnings
                } else {
                    term.write(data);
                }
            });

            ipcRenderer.on('terminal-error', (event, data) => {
                const data_lower = data.toLowerCase();
                if (data.includes("INFO:") || data.includes("DEBUG:") || data.includes("ERROR:") || data.includes("[OCR")) {
                    return; // BAD STDERR, NOT SURE WHY THIS IS HAPPENING
                }
                if (data_lower.includes('ocr:__init__')) {
                    term.write(`\x1b[32mOCR Initialization: ${data}\x1b[0m`); // Green text for OCR initialization
                    return;
                }
                if (data.includes("Transcribe:")) {
                    const transcription = data.split("Transcribe:")[1].trim();
                    term.write(`\x1b[32mTranscription: ${transcription}\x1b[0m`); // Green text for transcriptions
                    return
                }
                term.write(`\x1b[91m${data}\x1b[0m`); // Light red text for errors, no background
            });

            term.attachCustomKeyEventHandler((arg) => {
                if (arg.ctrlKey && arg.code === "KeyC" && arg.type === "keydown") {
                    const selection = term.getSelection();
                    if (selection) {
                        clipboard.writeText(selection);
                        return false;
                    }
                }
                return true;
            });

            document.getElementById("terminal").addEventListener('contextmenu', () => {
                if (term.hasSelection()) {
                    document.execCommand('copy')
                    term.select(0, 0, 0)
                } else {
                    ipcRenderer.send('terminal-data', clipboard.readText())
                }
            })
        </script>
    </div>
    <script>

        async function loadSettings() {
            const settings = await ipcRenderer.invoke('settings.getSettings');
            if (settings) {
                // autoUpdateGSMAppCheckbox.checked = settings.autoUpdateGSMApp || false;
                // autoUpdateElectronCheckbox.checked = settings.autoUpdateElectron || false;
                // pythonPathInput.value = settings.pythonPath || '';
                // agentScriptsPathInput.value = settings.agentScriptsPath || '';
                // startConsoleMinimizedCheckbox.checked = settings.startConsoleMinimized || false;
                // customPythonPackageInput.value = settings.customPythonPackage || 'GameSentenceMiner';
                // let showYuzuTab = settings.showYuzuTab || false;
                // if (showYuzuTab) {
                //     document.getElementById('yuzu-button').style.display = 'inline-block';
                // } else {
                //     document.getElementById('yuzu-button').style.display = 'none';
                // }
            }
        }

        // const { ipcRenderer } = require('electron');

        // function loadNewPage(url) {
        //     ipcRenderer.send('load-page', url); // Send the URL to the main process
        // }

        // Example usage: load a new page when a button is clicked
        // const tabButtons = document.querySelectorAll('.tab-button');
        // tabButtons.forEach(button => {
        //     button.addEventListener('click', () => {
        //         const selectedTab = button.dataset.tab;
        //         const otherContents = document.querySelectorAll('.tab-content:not(#' + selectedTab + ')');
        //
        //         document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        //         button.classList.add('active');
        //
        //         // Hide all other contents and show the selected one
        //         otherContents.forEach(content => content.classList.remove('active'));
        //
        //         // Load the selected page
        //         loadNewPage(selectedTab + '.html');
        //     });
        // });
        //
        // loadNewPage("console.html")
        let fitInterval;
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons and content
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                fitAddon.fit();

                // Add active class to clicked button and corresponding content
                const tabId = button.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
                button.classList.add('active');


                if (tabId === 'console') {
                    fitInterval = setInterval(async () => {
                        fitAddon.fit();
                    }, 1);

                    setTimeout(() => {
                        clearInterval(fitInterval);
                    }, 100);
                } else {
                    clearInterval(fitInterval);
                }

                if (tabId === 'stats') {
                    // Load localhost:55000/overview into the iframe
                    const statsIframe = document.querySelector('#stats iframe');
                    statsIframe.src = "http://localhost:55000/overview"; // Force reload
                }

                if (tabId === 'launcher') {
                    const launcherIframe = document.querySelector('#launcher iframe');
                    launcherIframe.src = launcherIframe.src; // Force reload
                }

                // Notify main process of tab change
                ipcRenderer.send('tab-changed', tabId);
            });
        });

        // Listen for installation messages from main process
        ipcRenderer.on('installing', (event, data) => {
            // showPythonStatus(data.message, 'info');
            // Optionally switch to console tab to show progress
            switchToConsoleTab();
        });

        // Initialize Python tab on DOM load
        initializePythonTab();

        loadSettings();
        setInterval(loadSettings, 500);

        // Initialize Python tab functionality
        function initializePythonTab() {
            // Load Python info on page load
            // loadPythonInfo();

            // CUDA Installation
            document.getElementById('install-cuda-btn').addEventListener('click', async () => {
                const cudaVersion = document.getElementById('cuda-version-select').value;
                showPythonStatus(`Installing CUDA ${cudaVersion}... This may take several minutes.`);
                switchToConsoleTab(); // Switch to console to see progress

                try {
                    const result = await ipcRenderer.invoke('python.installCudaPackage', cudaVersion);
                    if (result.success) {
                        showPythonStatus(`‚úÖ ${result.message}`, 'success');
                    } else {
                        showPythonStatus(`‚ùå ${result.message}`, 'error');
                    }
                } catch (error) {
                    showPythonStatus(`‚ùå Error installing CUDA: ${error.message}`, 'error');
                }
            });

            // CUDA Guide
            document.getElementById('cuda-guide-btn').addEventListener('click', async () => {
                await ipcRenderer.invoke('python.openCudaGuide');
            });

            // Repair GSM
            // document.getElementById('repair-gsm-btn').addEventListener('click', async () => {
            //     if (confirm('THIS IS ONLY TO BE USED IF SOMETHING IS COMPLETELY BROKEN WITH GSM DUE TO A CUSTOM/BAD PYTHON PACKAGE INSTALLATION. THIS SHOULD NOT BE EXPECTED TO FIX MINOR ISSUES, AND HAS A HIGHER CHANCE OF DOING MORE PAIN THAN GOOD.\n\nAre you sure you want to proceed with repairing GSM?')) {
            //         showPythonStatus('üîß Repairing GSM... This may take several minutes.');
            //         switchToConsoleTab(); // Switch to console to see progress

            //         try {
            //             const result = await ipcRenderer.invoke('python.repairGSM');
            //             if (result.success) {
            //                 showPythonStatus(`‚úÖ ${result.message}`, 'success');
            //                 loadPythonInfo(); // Refresh info after repair
            //             } else {
            //                 showPythonStatus(`‚ùå ${result.message}`, 'error');
            //             }
            //         } catch (error) {
            //             showPythonStatus(`‚ùå Error repairing GSM: ${error.message}`, 'error');
            //         }
            //     }
            // });

            // Clean cache
            document.getElementById('clean-cache-btn').addEventListener('click', async () => {
                showPythonStatus('üßπ Cleaning Python cache...');

                try {
                    const result = await ipcRenderer.invoke('python.cleanCache');
                    if (result.success) {
                        showPythonStatus(`‚úÖ ${result.message}`, 'success');
                    } else {
                        showPythonStatus(`‚ùå ${result.message}`, 'error');
                    }
                } catch (error) {
                    showPythonStatus(`‚ùå Error cleaning cache: ${error.message}`, 'error');
                }
            });

            // Install custom package
            document.getElementById('install-custom-package-btn').addEventListener('click', async () => {
                const packageName = document.getElementById('custom-package-input').value.trim();
                if (!packageName) {
                    alert('Please enter a package name');
                    return;
                }

                showPythonStatus(`Installing package: ${packageName}...`);
                switchToConsoleTab(); // Switch to console to see progress

                try {
                    const result = await ipcRenderer.invoke('python.installCustomPackage', packageName);
                    if (result.success) {
                        showPythonStatus(`‚úÖ ${result.message}`, 'success');
                        document.getElementById('custom-package-input').value = ''; // Clear input
                    } else {
                        showPythonStatus(`‚ùå ${result.message}`, 'error');
                    }
                } catch (error) {
                    showPythonStatus(`‚ùå Error installing package: ${error.message}`, 'error');
                }
            });

            // Refresh Python info
            document.getElementById('refresh-python-info-btn').addEventListener('click', loadPythonInfo);

            // Allow Enter key in package input
            document.getElementById('custom-package-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('install-custom-package-btn').click();
                }
            });
        }

        async function loadPythonInfo() {
            try {
                const info = await ipcRenderer.invoke('python.getPythonInfo');
                if (info.success) {
                    document.getElementById('python-version').textContent = `Python Version: ${info.pythonVersion}`;
                    document.getElementById('python-path').textContent = `Python Path: ${info.pythonPath}`;
                    document.getElementById('pip-version').textContent = `Pip Version: ${info.pipVersion}`;
                } else {
                    document.getElementById('python-version').textContent = 'Python Version: Error loading';
                    document.getElementById('python-path').textContent = 'Python Path: Error loading';
                    document.getElementById('pip-version').textContent = 'Pip Version: Error loading';
                }
            } catch (error) {
                console.error('Failed to load Python info:', error);
            }
        }

        function showPythonStatus(message, type = 'info') {
            const statusCard = document.getElementById('python-status-card');
            const statusText = document.getElementById('python-status-text');

            statusText.textContent = message;
            statusCard.style.display = 'block';

            // Auto-hide success/error messages after 10 seconds
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    statusCard.style.display = 'none';
                }, 10000);
            }
        }

        // Setup collapsible sections for Python tab
        function setupPythonCollapsibleSections() {
            const pythonHeaders = document.querySelectorAll('#python .collapsible-header');
            pythonHeaders.forEach(header => {
                header.addEventListener('click', function () {
                    const content = this.nextElementSibling;
                    const arrow = this.querySelector('.arrow-icon');

                    if (content.style.display === 'none' || content.style.display === '') {
                        content.style.display = 'block';
                        arrow.textContent = '‚ñ≤';
                    } else {
                        content.style.display = 'none';
                        arrow.textContent = '‚ñº';
                    }
                });
            });
        }

        // Initialize collapsible sections
        setupPythonCollapsibleSections();
        
        // ====================================================================
        // Shared State: Detect and store OS information for all pages
        // ====================================================================
        
        async function detectAndStoreOSInfo() {
            // Detect the OS
            const isWindows = process.platform === 'win32';
            const isMac = process.platform === 'darwin';
            const isLinux = process.platform === 'linux';
            // const isWindows = false;
            // const isMac = true;
            // const isLinux = false;
            
            const osInfo = {
                platform: process.platform,
                isWindows,
                isMac,
                isLinux,
                detectedAt: Date.now()
            };
            
            // Store in shared state so all pages can access it
            await sharedState.setState('systemInfo', osInfo);
            console.log('üñ•Ô∏è System Information detected and stored:', osInfo);
        }
        
        // Detect OS on page load
        detectAndStoreOSInfo();
    </script>
</body>

</html>